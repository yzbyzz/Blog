<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[就像每次学一门语言都会先写个 Hello World 程序，每次写博客也都要写一个 Hello World 文章。我已经记不清自己是第几次写这种文章。没错，我又一次想要更新博客，这次不知道能不能坚持下去。 以前也写过几段时间的博客，但都是三分钟热度、半途而废。大多数时候都是因为注意力被其他事情吸引过去（比如游戏、动漫），导致没有时间可以分配给写作，慢慢地也就淡忘了。现在几乎不玩游戏，动漫也看的少，我倒要看看这次会是什么原因导致停更。 这篇文章作为一个开始，为了让自己坚持下去，也趁着新年，给自己制定几个明确、可执行、可衡量的 Flag 目标： 早睡早起。 7 点半前醒，12 点半前睡。 7 点后的第一次睁眼就必须醒来，不能等到 7 点半闹钟响才醒。 起来后看点书。 坚持更新博客。每天都写一点，但每两周要更新一篇。 坚持每日微运动。每天抽出十分钟做点简单的运动。 每个月或每个季度更新一下这篇文章——也就是个人的目标。 无论工作日还是休息日这些目标都生效，只有回老家或者出去玩的时候是例外。另外，毕竟我还是人，不是机器。所以每个目标在每个月给自己两次偷懒的机会。如果偷懒超过限制，就得给自己一些惩罚。暂时想到的惩罚有： 在票圈发某宝口令红包。 不看动漫一周。 也许以后会想到更有效的惩罚，到时再更新。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>不断更新</tag>
        <tag>Flag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 编译与链接]]></title>
    <url>%2F2017%2F08%2F27%2Flinux-compile-link%2F</url>
    <content type="text"><![CDATA[Linux 下 C/C++ 代码编译链接生成可执行程序的过程，主要包括如下几个步骤。 预处理12#只进行预处理并把预处理结果输出g++ -E source.cpp -o source.i 预处理过程主要处理源代码文件中以 # 开始的预编译指令，包括如下规则。 将所有的 #define 删除，并且展开所有的宏定义。 处理所有的条件预编译指令，包括 #if、 #ifdef、 #ifndef、 #elif、 #else、 #endif 等。 处理 #include 预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件，也会同样被插入。 过滤所有的注释中的内容，包括 // 和 /* */。 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。 保留所有的 #pragma 编译器指令，因为编译器需要使用它们。 编译12#输出编译后的汇编代码文件g++ -S source.i -o source.s 编译过程就是把预处理完的文件进行如下的一系列操作后产生相应的汇编代码文件。这个过程往往是整个程序构建的核心部分，也是最复杂的部分之一。 词法分析 语法分析 语义分析 源代码优化 代码生成 目标代码优化这里不展开一一赘述。 通过如下命令，我们可以直接从源文件得到目标文件/中间代码文件，如 .o 文件。 12#只编译不链接g++ -c source.cpp 链接各个源代码模块独立地编译成目标文件，链接就是把这些目标文件和库链接形成可执行文件的过程。这里的“库”指的是：一组目标文件的包，也就是将一些常用的代码编译成目标文件后打包存放，便于使用。链接分为静态链接和动态链接。 静态链接对函数库的链接是放在编译时期完成的是静态链接。静态库文件命名格式为：libNAME.a 。有如下 5 个文件： 12345//add.h#ifndef _ADD_H_#define _ADD_H_int add(int a, int b);#endif 123456//add.cpp#include "add.h"int add(int a, int b)&#123; return a + b;&#125; 12345//sub.h#ifndef _SUB_H_#define _SUB_H_int sub(int a, int b);#endif 123456//sub.cpp#include "sub.h"int sub(int a, int b)&#123; return a - b;&#125; 1234567891011//main.cpp#include "add.h"#include "sub.h"#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "1+2=" &lt;&lt; add(1, 2) &lt;&lt; endl; cout &lt;&lt; "1-2=" &lt;&lt; sub(1, 2) &lt;&lt; endl; return 0;&#125; 生成静态库并链接形成可执行文件的过程如下：将 add.cpp 和 sub.cpp 编译成 .o 文件12g++ -c add.cppg++ -c sub.cpp 由 .o 文件创建静态库1ar cr libmymath.a sub.o add.o 链接静态库并生成可执行文件 main123# -L 额外指定库搜索路径# -l 额外指定链接的库g++ -o main main.cpp -L. -lmymath ar 命令用于创建和维护库文件。 c 选项：不管是否已存在，创建一个库。 r 选项： 在库中插入或替换模块。 tv 选项： 显示库中有哪些目标文件，显示文件名、时间、大小等详细信息。 运行1./main 动态链接对库函数的链接载入推迟到程序运行时期就是动态链接。动态库文件命名格式为：libNAME.so 。同样以上面的 5 个文件为例。 如果你边跟着本文顺序，边在动手实践的话，此时请暂时将静态库文件 libmymath.a 删除或重命名成其他名字。减少干扰。 生成动态库并链接形成可执行文件的过程如下：生成动态库1234567# 1.g++ -fPIC -o add.o -c add.cppg++ -fPIC -o sub.o -c sub.cppg++ -shared -o libmymath.so add.o sub.o# 或者# 2.g++ -fPIC -shared -o libmymath.so add.cpp sub.cpp -fPIC 编译为位置独立的代码。 生成目标文件1g++ -o main main.cpp -L. -lmymath 运行1./main CentOS 等 Linux 系统下直接运行会报错./main: error while loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory 使用 ldd 命令来查看目标文件shell ldd main shell linux-vdso.so.1 =&gt; (0x00007ffefc135000) libmymath.so =&gt; not found libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007ff6d629e000) libm.so.6 =&gt; /lib64/libm.so.6 (0x00007ff6d5f9c000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007ff6d5d86000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007ff6d59c4000) /lib64/ld-linux-x86-64.so.2 (0x00007ff6d65af000) 这是因为系统运行 main 时，会按照如下顺序搜索动态库： 编译目标代码时指定的动态库搜索路径 环境变量 LD_LIBRARY_PATH 指定的动态库搜索路径 配置文件 /etc/ld.so.conf 中指定的动态库搜索路径 默认的动态库搜索路径 /lib 默认的动态库搜索路径 /usr/lib也就找不到我们生成的 libmymath.so 。 相应地有以下几种方法可以告诉系统如何找到我们需要的动态库。 编译时增加 -Wl,-rpath来指定额外的动态库搜索路径。当指定多个动态库搜索路径时，路径之间用冒号 ： 分隔。shell g++ -o main main.cpp -L. -lmymath -Wl,-rpath=. 修改环境变量 LD_LIBRARY_PATHshell export LD_LIBRARY_PATH=/PATH_TO_LIB:$LD_LIBRARY_PATH 修改配置文件 /etc/ld.so.conf sudo vi /etc/ld.so.conf将动态库所在路径添加到 ld.so.conf 中PATH_TO_LIB使修改生效sudo ldconfig 将我们的库添加到默认路径中 1234567sudo cp libmymath.so /usr/lib# 或sudo cp libmymath.so /lib# 如果复制后还是找不到动态库文件，可执行下述命令，详情请看 参考里的 ldconfig 详解# sudo ldconfig MacOS 下系统会自动在目标文件所在路径寻找动态库文件，所以可以直接运行不会报错。Mac 下没有 ldd命令， 可通过 otool -L来查看目标文件的依赖。 1otool -L main 1234main: libmymath_one.so (compatibility version 0.0.0, current version 0.0.0) /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.5.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.60.2) 动态库和静态库同名问题以上述文件为例，我们在同一目录中分别执行命令生成动态库和静态库，即 libmymath.so和 libmymath.a。此时执行 g++ -o main main.cpp -L. -lmymath，然后运行目标文件 ./main，会看到./main: error while loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory也就是说编译器优先采用了动态链接来生成目标文件：首先到path目录下搜索 libXXX.so动态库文件，如果没有找到，才会搜索 libXXX.a静态库文件。 动态库与静态库的对比 动态库 有利于进程间资源共享，减少资源占用。 方便升级。只要接口不变，程序无需重新编译。 链接载入完全由程序员在程序代码中控制。 静态库 执行速度快。 编译后静态库已打包在目标文件中，减少了依赖。 g++ 与 gcc 的对比 g++ 和 g++ 都可以编译 C++ 代码。在编译阶段 g++ 会自动调用 gcc ，两者是等价的。 后缀为 .c 的代码， gcc 把它当作是 C 程序， 而 g++ 当作 C++ 程序；后缀为 .cpp 的，两者都会将其当作 C++ 程序。 链接可以用 g++ 或 gcc-lstdc++ 。 gcc 命令不能自动和 C++ 程序使用的库链接。 __cplusplus宏标志着编译器会把代码按 C 还是 C++ 语法来解释。对于 g++ 来说，该宏都会定义；对于 gcc 来说，该宏是否定义取决于文件后缀。 以下述 .c 文件为例。 123456789101112#source.c#include &lt;stdio.h&gt;int main()&#123;#ifdef __cplusplus printf("define __cplusplus\n");#else printf("undefine __cplusplus\n");#endif return 0;&#125; 使用 gcc 编译生成目标文件并运行 12gcc -o source source.c./source 会看到 1undefine __cplusplus 将后缀改成 .cpp ，重新编译运行 123mv source.c source.cppgcc -o source source.cpp./source 会看到 1define __cplusplus g++ 和 gcc 对采用了 extern &quot;C&quot;的 symbol 都会以 C 的方式来命名。 以下述文件为例 12345// me.h#ifndef _ME_H_#define _ME_H_extern "C" void CppPrintf(void);#endif 12345678// me.cpp#include &lt;iostream&gt;#include "me.h"using namespace std;void CppPrintf(void)&#123; cout &lt;&lt; "Hello" &lt;&lt; endl;&#125; 1234567// test.cpp#include "me.h"int main()&#123; CppPrintf(); return 0;&#125; 执行下述命令 12345gcc -S me.cpp# 或者# g++ -S me.cpp# 效果相同less me.s 可以看到 1call CppPrintf 将 me.h 中的 extern &quot;C&quot;删除后，执行下述命令 12345gcc -S me.cpp# 或者# g++ -S me.cpp# 效果相同less me.s 可以看到 1call _Z9CppPrintfv 参考 《后台开发：核心技术与应用实践》第 4 章 编译 ldconfig 命令]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>编译</tag>
        <tag>旧文补发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些 iOS 编译错误的原因及其解决方法]]></title>
    <url>%2F2017%2F08%2F26%2F%E4%B8%80%E4%BA%9B-iOS-%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近工作涉及到 iOS，使用过程中经常遇到不少错误，特此记录，以备查询。 所用环境为 Max OS 10.12.6 Xcode 8.3.3 iOS 10.3.3 0.出现错误后，在红色错误信息处，“右键 - Reveal in log - Detail Message” 会看到详细的出错信息，一般能从这里看到具体的问题是什么，然后采取相应的措施。 简单来说，就是两步“Google error message”、“Copy from StackOverFlow” 。 有时候一种现象，背后会有多种原因，于是就需要多试几种方法。总会解决的:). 由于本人对 iOS 完全是一知半解，如有不对之处，还望指出，不吝感激。 1. Applications are expected to have a root view controller at the end of application launchhttps://stackoverflow.com/questions/7520971/applications-are-expected-to-have-a-root-view-controller-at-the-end-of-applicati/32680220#32680220 iOS 从某个版本之后每个 window都要设置一个 RootViewController。否则在运行时便会挂掉。 检查你的 AppDelegate.m 文件（或者是 XXXXAppDelegate.m 文件）的 didFinishLaunchingWithOptions 函数。如果函数中是如下形式： [window addSubview:[someController view]];则将其改为 [self.window setRootViewController:someController];如果修改之后，仍报同样的错误。说明你程序中有不止一个 window ，而你并没有为每个 window 都设置了 RootViewController 。全部设置相应的 RootViewController 后即可解决。 需要注意的是 iOS 会默认根据 xib/storyboard 生成一个 window （本人对 iOS 并不是很熟，如果这里说法有误，欢迎指正）。所以有时候，你只有一个 window ，并且设置了 RootViewController 后还报错，则需要将类似如下代码的创建 window 的代码删除。 1self.window = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]] autorelease]; 2. 模拟器上正常运行，真机测试时报错 &quot;_WebPGetFeaturesInternal&quot;, referenced from: &quot;_png_get_io_ptr&quot;, referenced from: &quot;_TIFFGetField&quot;, referenced from: &quot;_jpeg_read_header&quot;, referenced from: &quot;_TIFFClientOpen&quot;, referenced from: &quot;_FT_Get_Glyph&quot;, referenced from: “右键 - Reveal in log - Detail Message” ，可看到 Undefined symbols for architecture arm64 这种情况通常是程序在 Build 的过程中没有将用到的所有 Library 链接进去。 通过“选中项目 - TARGETS - Build Phases - Link Binary With Libraries” ，并根据上面报错的名字，将相应的 Library 添加进去即可。 我这里是因为用了 cosos2d ，所以将 /PATH_TO_COSOS2D/cocos2d/external/XXX_MODULE/prebuilt/ios/libXXX[_arm64].a 包含进去即可。 将库添加后，如果还报错，则需在“项目 - Build Setting - Library Search Paths” 中添加“刚才添加的库”的目录。（在后面选择 recursive 可使编译器搜索指定目录及其子目录。) 3. unknow type name ‘namespace’等诸如 C++ 中的语法，编译时报错。通常报错的文件是 .h 文件，而包含该文件的是 .h 或 .m 文件。将 .m 后缀修改成 .mm 后缀，编译器便会将该文件当做 Objective-C++ 文件来编译。 或者选中文件后，在右侧的 “Identity and Type - Type” 中选择 “Objective-C++ File” 也可达到同样的效果。 4. library not found for -lcrt1.3.1.ohttp://blog.csdn.net/skylin19840101/article/details/56008803 crt1.3.1.o is a library that was included in older iOSes (and thus, their SDKs) but is no longer present in newer SDKs. However, when the project’s Deployment Target is set to an older ios (&lt;6.0, as @Sandy has found), Xcode still tries linking against it.在 iOS6 以及更高的版本中，crt1.3.1.o 已经没有了。 修改支持的最低 iOS 系统版本在 “项目 - TARGETS - General -&gt; Deployment Info -&gt; Deployment Target” 中，把 5.0(及以下的)改为 6.0(及以上的) 5. Use of undeclared identifier ‘glDeleteTextures’https://stackoverflow.com/questions/24024764/errors-showing-for-oes-opengl-statements-in-xcode-6-for-ios8添加如下代码 #import &lt;OpenGLES/ES2/glext.h&gt; 6. ‘release’ is unavailable: not available in automatic reference counting modehttps://stackoverflow.com/questions/22996437/release-is-unavailable-not-available-in-automatic-reference-counting-mode Xcode 设置中开启了 ARC ， 但是代码仍然进行了内存释放等操作。要么关闭 ARC ， 要么去掉代码中的释放内存相关的代码。 7. clang:error: -fembed-bitcode is not supported on versions of iOS prior to 6.0或者 12345/PATH_TO_COSOS2D/cocos2d/external/freetype2/prebuilt/ios/libfreetype.a(ftbase.o)'does not contain bitcode.You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE),obtain an updated library from the vendor,or disable bitcode for this target. for architecture armv7 这都是因为新的 iOS 不支持 bitcode 选项。将 “项目 - TARGETS - Build Setting - Enable Bitcode” ， 改为 no 即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>旧文补发</tag>
        <tag>XCode</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
