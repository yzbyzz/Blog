<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F05%2FHello-World%2F</url>
    <content type="text"><![CDATA[就像每次学一门语言都会先写个 Hello World 程序，每次写博客也都要写一个 Hello World 文章。我已经记不清自己是第几次写这种文章。没错，我又一次想要更新博客，这次不知道能不能坚持下去。 以前也写过几段时间的博客，但都是三分钟热度、半途而废。大多数时候都是因为注意力被其他事情吸引过去（比如游戏、动漫），导致没有时间可以分配给写作，慢慢地也就淡忘了。现在几乎不玩游戏，动漫也看的少，我倒要看看这次会是什么原因导致停更。 这篇文章作为一个开始，为了让自己坚持下去，也趁着新年，给自己制定几个明确、可执行、可衡量的 Flag 目标： 早睡早起。 7 点半前醒，12 点半前睡。 7 点后的第一次睁眼就必须醒来，不能等到 7 点半闹钟响才醒。 起来后看点书。 坚持更新博客。每天都写一点，但每两周要更新一篇。 坚持每日微运动。每天抽出十分钟做点简单的运动。 每个月或每个季度更新一下这篇文章——也就是个人的目标。 无论工作日还是休息日这些目标都生效，只有回老家或者出去玩的时候是例外。另外，毕竟我还是人，不是机器。所以每个目标在每个月给自己两次偷懒的机会。如果偷懒超过限制，就得给自己一些惩罚。暂时想到的惩罚有： 在票圈发某宝口令红包。 不看动漫一周。 也许以后会想到更有效的惩罚，到时再更新。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>不断更新</tag>
        <tag>Flag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Java 中初始化 List 的五种方法]]></title>
    <url>%2F2018%2F11%2F02%2F%E5%9C%A8-Java-%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96-List%2F</url>
    <content type="text"><![CDATA[Java 中经常需要使用到 List，下面简单介绍几种常见的初始化方式。 1.构造 List 后使用 List.add 初始化1234List&lt;String&gt; stringList = new LinkedList&lt;&gt;();stringList.add("a");stringList.add("b");stringList.add("c"); 这是最常规的做法，用起来不太方便。 2.使用 \{\{\}\} 双括号语法12345List&lt;String&gt; stringList = new LinkedList&lt;String&gt;()&#123;&#123; add("a"); add("b"); add("c");&#125;&#125;; 这种方式相对方便了一些。 外层的 {} 定义了一个 LinkedList 的匿名内部类。内层的 {} 的定义了一个实例初始化代码块。 这个代码块在初始化内部类时执行。所以这里相当于定义了一个匿名内部类，并使用 add 添加元素来初始化。 这种方式有几个缺点： 使用匿名内部类，会有效率上的损失。当然在大多数情况下，这点效率都是可接受的。 静态内部类持有所在外部类的引用。如果需要将 List 返回给到其他地方使用，可能造成内存泄漏。 3.使用 Arrays.asList1List&lt;String&gt; stringList = Arrays.asList("a", "b", "c"); 这种方式使用了 java.util.Arrays 的静态方法。写法上比之前的两种都更简洁，也没有构造匿名内部类的效率问题。 但也有几点需要注意： Arrays.asList 返回的是 Arrays 的静态内部类（静态内部类不持有所在外部类的引用）。 这个内部类继承自 AbstractList，实现了 RandomAccess，内部使用了一个数组来存储元素。但是不支持增删元素。这点需要注意。如果只是使用 Arrays.asList 来初始化常量，那么这点就不算什么问题了。 Arrays.asList 的参数如果是基本类型的数组时，需要留意返回值可能和你预期的不同。 123456int[] intArray = new int[]&#123;1, 2, 3&#125;;Integer[] integerArray = new Integer[]&#123;1, 2, 3&#125;; List&lt;int[] &gt; intArrayList = Arrays.asList(intArray);List&lt;Integer&gt; integerList = Arrays.asList(integerArray);List&lt;Integer&gt; integerList2 = Arrays.asList(1, 2, 3); 这里 Arrays.asList(intArray) 的返回值是 List&lt;int[]&gt; 而不是 List&lt;Integer&gt;。这一点也算不上问题，只是使用时需要留意。如果能在 Java 中做到尽量使用 List 和 Integer，尽量避免使用 int 等基本类型和 [] 这种较为底层的数据结构即可避免。 说点题外话：Java 终究还是不能称之为完全面向对象。毕竟保留了基本数据类型这种东西。诚然基本数据类型使用时比相应的封装类型效率要更高。但也给使用过程中带来了一些困惑：到底该用基本类型，还是封装类型，什么时候该用这个，什么时候该用哪个？虽然 Java 提供给了用户更多的选择，但有种将难题丢给用户的感觉。在我看来，Java 相比的 C++ 一个优点，就是很多事情有了限制，有较为明确清晰的定义，减少了模棱两可，更容易理解。但基本数据类型这里，感觉还是 Java 作为一门改善了 C++ 缺点的语言留下的一些影子。 虽然本文是在讲初始化 List，但这里的 \{\{\}\} 双括号语法同样可用于初始化 Map 等其他众多类型。相对而言，Arrays.asList 就只能用于初始化 List 类型了。 4. 使用 Stream (JDK8)1List&lt;String&gt; list = Stream.of("a", "b", "c").collect(Collectors.toList()); 使用了 JDK8 的 Stream 来初始化。 单纯初始化 List，使用 Stream 有点大材小用了。 5. 使用 Lists （JDK9）1List&lt;String&gt; list = Lists.newArrayList("a", "b", "c"); 这个和 Arrays.asList 一样简洁清晰。 参考Double Brace Initialization How to initialize List object in Java?]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>旧文补发</tag>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符集和字符编码]]></title>
    <url>%2F2018%2F05%2F18%2F%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[字符集和字符编码字符集字符集，从字面意思来讲，就是某些特定字符的集合。 ASCII 字符集包括了大小写英文字母、数字、英文标点符号和控制字符等在内的 128 个字符； GBK 字符集除了包括 ASCII 字符集中的所有字符，还包括了汉字和中文标点符号； Unicode 字符集除了包括 ASCII 字符集中的字符，还包括了中文字符、日文字符等各种各样的字符。 字符集除了指定其中包含的字符，还为每个字符分配了一个唯一的代码值（通常是数字）来代表该字符。 这个代码值就称之为该字符在该字符集中的码点。 在 ASCII 字符集中用 65 来表示字符 A ；Unicode 字符集中用 U+0041 来表示字符 A 。（其中 U+ 是 Unicode 的固定前缀，0041 是一个 16 进制数字。） 另一方面，也可以说字符A 在 ASCII 字符集中的码点是 65，在 Unicode 字符集中的码点则是 U+0041。 编码表应该是字符集的另一种叫法？ ASCII 字符集： 字符编码字符编码：将字符按照一定的规则，转换成一个二进制数字，保存到计算机中。以及一个二进制数字，通过怎样的规则，转换成一个对应的字符。 在某种字符集中，将一个字符保存到计算机中时，由于一个字符对应了一个唯一的码点，所以通常情况直接保存该码点即可（比如 ASCII 编码就直接保存了字符在 ASCII 字符集中的码点），但有些时候却不是这样。 比如 Unicode 字符集。 Unicode 字符集包含了很多字符。 Unicode 的码点可以分成 17 个代码级别(code plane)。 第一个代码级别称为基本的多语言级别(basic multilingual plane )，码点从 U+0000 到 U+FFFF ，其中包括经典的 Unicode 代码；其余的 16 个级别码点从U+10000 到 U+10FFFF, 其中包括一些辅助字符(supplementary character)。 123456789101 个基本的多语言级别U+0000 ~ U+FFFF (65536 个)剩余的 16 个级别U+10000 ~ U+1FFFFU+20000 ~ U+2FFFF...U+E0000 ~ U+EFFFFU+F0000 ~ U+FFFFFU+100000 ~ U+10FFFF 要表示从 U+0000 到 U+10FFFF的 17 * 65536 = 1,114,112 个字符，需要 3 个字节。 虽然 Unicode 字符集包括了这么多的字符，但是我们常用的字符却只占其中的一小部分。 以英文字符为例，用 1 个字节来表示就能比用 3 个字节来表示节省 2/3 的空间。 这对于主要使用英文的西方国家来说，是一个不容忽略的空间。 所以就有了 UTF-8、UTF-16 等不同的编码方式来将 Unicode 字符集中的字符编码成占据不同字节大小的数字存储到计算机中。 UTF-8 编码使用 1 ~ 3 个字节来表示一个 Unicode 字符： 1 个字节可以表示 2^7 = 128 个字符，与 ASCII 字符集对应。 2 个字节可以表示 2^(5+6) = 2048 个字符。 3 个字节可以表示 2^(4+6+6) = 65536 个字符。 Byte 1 Byte 2 Byte3 0xxx xxxx 110x xxxx 10xx xxxx 1110 xxxx 10xx xxxx 10xx xxxx Ref字符集和字符编码（Charset &amp; Encoding）– 吴秦（Tyler） 字符编码笔记：ASCII，Unicode 和 UTF-8 – 阮一峰 十分钟搞清字符集和字符编码 – cenalulu]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>旧文补发</tag>
        <tag>字符集</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 核心技术]]></title>
    <url>%2F2018%2F05%2F17%2FJava-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[《Java 核心技术》把书中一些自己不熟悉或者自己认为比较重要的知识点，做个简单的记录备忘。 第 3 章 Java 的基本程序设计结构浮点数的科学表示法​12345678# 以 10 为底，尾数、指数都是十进制1.36e2 = 1.36E2 = 1.36 * 10^2 = 136# 以 2 为底，尾数是 16 进制，指数是十进制0x11p3 = 0x11P3 = 0x11 * 2^3 = 17 * 8 = 1360x1ap-1 = 0x1aP-1 = 0x1a * 2^-1 = 26 * 1/2 = 13​ / 与 floorDiv，% 与 floorMod​123456789101112131415161718192021222324（当 `/` 的操作数为整型时）`floorDiv` that returns the integer less than or equal to the quotientand the `/` operator that returns the integer closest to zero.`/` 返回的结果与实际的商相比更接近 0，即满足： abs（结果） &lt;= abs（实际的商）`floorDiv` 返回的结果小于等于实际的商。Examples:floorMod(12, 5) == 2, (12 / 5) == 2floorMod(-12, -5) == 2, (-12 / -5) == 2（-12.0 / 5 = 12.0 / -5 = -2.4）floorMod(-12, 5) == -3, (-12 / 5) == -2floorMod(12, -5) == -3, (12 / -5) == -2x % y = x - x / y * yx / y * y + x % y == xflorMod(x, y) = x - (floorDiv(x, y) * y)floorDiv(x, y) * y + floorMod(x, y) == x​ 数值类型之间的转换​12345678910111213 float -------&gt; double ^ -- -- ^ | |\ / | | . ./ . | / \ | . / . .byte ----&gt; short ----&gt; int --------&gt; long ^ | | char​ ​12345678910111213141516无损转换 可能丢失精度--&gt; -.-.&gt;^ ^| || .| || .丢失精度：int -&gt; floatlong -&gt; floatlong -&gt; double​ 位运算移位运算符 左操作数是 int 类型，右操作数模 32 。例如，1 &lt;&lt; 35 的值等同于 1 &lt;&lt; 3 或 8。 左操作数是 long 类型，右操作數要模 64。例如 5L &lt;&lt; 35 的值是 171798691840 ；5L &lt;&lt; 65 的值等于 5L &lt;&lt; 1 或 10。 &gt;&gt;&gt; 运算符会用 0 填充高位， 这与 &gt;&gt; 不同， 它会用符号位填充高位。 不存在 &lt;&lt;&lt; 运算符。 在 C/C++ 中，不能保证 &gt;&gt; 是完成算术移位（扩展符号位）还是逻辑移位（填充 0) 。实现者可以选择其中更高效的任何一种做法。 这意味着 C/C++ &gt;&gt; 运算符对于负数生成的结果可能会依赖于具体的实现。 Java 则消除了这种不确定性。 字符在 Java 中， char 类型描述了 UTF-16 编码中的一个代码单元。 字符串Java 中的 String 是不可变对象。 优点：编译器可以让字符串共享。 读取 / 比较字符串 比 修改字符串 多。 拼接字符串 可以使用 StringBuilder（线程不安全，效率高） 、 StringBuffer （线程安全，效率低）。 缺点：只修改字符串中的某些字符时不如 C/C++ 灵活。 ​123456789101112// JavaString s = "a string";System.out.println(s);// 拼接字符串s = "one part" + "." + "another part";System.out.println(s);// 修改某个字符后，生成了新字符串s = s.replace(".", ",");System.out.println(s);​ ​1234567891011121314// C++std::string s = "a string";std::cout &lt;&lt; s &lt;&lt; std::endl;std::string a = "one part";std::string b = ".";std::string c = "another part";s = a + b + c;std::cout &lt;&lt; s &lt;&lt; std::endl;// 在原字符串上修改s.replace(a.length(), b.length(), ",");std::cout &lt;&lt; s &lt;&lt; std::endl;​ ​123456789101112131415161718192021222324// Cchar *s = "a string";puts(s);// 拼接字符串，比较麻烦char *a = "one part";char *b = ".";char *c = "another part";int al = strlen(a);int bl = strlen(b);int cl = strlen(c);char *tmp = new char[al + bl + cl + 1];strncpy(tmp, a, al);strncpy(tmp + al, b, bl);strncpy(tmp + al + bl, c, cl);tmp[al + bl + cl] = '\0';s = tmp;puts(s);// 直接修改某个字符s[al] = ',';puts(s);​ ​12345// outputa stringone part.another partone part,another part​ 比较字符串使用 equals 或 equalsIgnoreCase 或 compareTo，不能用 ==（比较的是两个对象指向的地址是否相同）。 Java 中对字符串的 + 运算进行了重载，却没有对 == 进行重载。 如果重载了 == ，那包括字符串在内的所有对象都将用 == 来判断是否相等。 像现在 == 用来判断指向的地址是否，其实很少用？ 获取长度 length 获取字符串中有多少个 char，即字符串用 UTF-16 编码时，需要的单元数量（一个单元 2 个字节） codePointCount 获取字符串的实际长度，即字符串中有多少个字符 / Unicode 码点。 码点、字符集、字符编码的一些概念见 0518 字符集和字符编码。 ​12345678910111213141516171819202122String s = "\uD835\uDD46";// 𝕆(U+1D546) 需要两个代码单元System.out.println("s=" + s);System.out.println("length=" + s.length());System.out.println("codePointCount=" + s.codePointCount(0, s.length()));for (int i = 0; i &lt; s.length(); i++) &#123; System.out.println(i + ":" + s.charAt(i) + ", " + (int)s.charAt(i));&#125;int[] codePoints = s.codePoints().toArray();for (int i = 0; i &lt; codePoints.length; i++) &#123; System.out.println(i + ":" + codePoints[i]);&#125;/*s=𝕆length=2codePointCount=10:?, 553491:?, 566460:120134*/​ 尽量避免使用 char 类型和 String 的 charAt 方法，因为它们太底层了。 控制台输入 Scanner 1234Scanner in = new Scanner(System.in);in.next();in.nextInt();... Console ，输入是不可见的 如果有可能进行交互操作，就通过控制台窗口为交互的用户返回一个 Console 对象， 否则返回 null。对于任何一个通过控制台窗口启动的程序都可使用 Console 对象 。否则， 其可用性将与所使用的系统有关。 123Console cons = System.console();String username = cons.readLine("Username: ");char[] passwd = cons.readPassword("Password: "); 格式化字符串复用参数的方法 采用一 个格式化的字符串指出要被格式化的参数索引。索引必须紧跟在 % 后面， 并以$ 终止。 参教索引值从 1 开始 。 ​123System.out.printf("a=%1$04d b=%2$s c=%3$.2f d=%2$s\n", 12, "STR", 9.87);//a=0012 b=STR c=9.87 d=STR​ 使用 &lt; 标志，它指示前面格式说明中的参数将被再次使用 ​123System.out.printf("a=%1$04d b=%2$s b=%&lt;s c=%3$.2f c=%&lt;.4f\n", 12, "STR", 9.87);//a=0012 b=STR b=STR c=9.87 c=9.8700​ 第 4 章 对象与类类之间的关系 依赖 uses-a 聚合 has-a 继承 is-a static Java 中的静态域与静态方法在功能上与 C++ 相同。但是， 语法书写上却稍有所不同。在 C++ 中， 使用 :: 操作符访问自身作用域之外的静态域和静态方法， 如 Math::PI。 术语 static 有一段不寻常的历史： 起初， C 引入关键字 static 是为了表示退出一个块后依然存在的局部变量。在这种情况下， 术语 static 是有意义的：变量一直存在 ，当再次进入该块时仍然存在。 随后，static 在 C 中有了第二种含义，表示不能被其他文件访问的全局变量和函数。 为了避免引入一个新的关键字， 关键字 static 被重用了。 最后，C++ 第三次重用了这个关键字， 与前面赋予的含义完全不一样， 这里将其解释为：属于类且不属于类对象的变量和函数。 这个含义与 Java 相同。 方法参数 call by …call by 描述各种程序设计语言（不只是 Java) 中方法参数的传递方式： 按值调用 (call by value) 表示方法接收的是调用者提供的值。 按引用调用 (call by reference) 表示方法接收的是调用者提供的变量地址。 按名调用 (call by name)，Algol 程序设计语言是最古老的高级程序设计语言之一， 它使用的就是这种参数传递方式。不过，这种传递方式已经成为历史。 一个方法可以修改传递引用所对应的变量值， 而不能修改传递值调用所对应的变量值。Java 程序设计语言总是采用按值调用。对象引用是按值传递的。 基本数据类型：形参改变，不影响实参。 对象引用： 同样有“形参改变，不影响实参”，即将形参引用了其他对象，实参还是引用原来的对象。 但是形参初始时和实参的值相等，即引用了相同的对象，通过形参对被引用的对象进行修改，通过实参来访问被引用对象时，相应的值也会变化。 Java 中方法对参数的影响 一个方法不能修改一个基本数据类型的参数 （即数值型或布尔型）。 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。 C++ 中有值调用和引用调用。引用参数使用 &amp;，可以达到在函数中改变参数所引用的对象。 变量初始化默认值 局部变量必须初始化后才能使用 类的变量，如果没有初始化，会有默认值（0, false, null） 如何初始化 在构造器中设置值 在声明中赋值 在初始化块中赋值 ​1234567891011class Cls &#123; &#123; // 对象初始化块 // 每次创建一个对象，都会执行该代码块 &#125; static &#123; // 静态初始化块 // 仅在类第一次加载时，执行 &#125;&#125;​ 调用构造器的处理过程 1 ) 所有数据域被初始化为默认值 (0、 false 或 null 。) 2 ) 按照在类声明中出现的次序， 依次执行所有域初始化语句和初始化块 3 ) 如果构造器第一行调用了第二个构造器， 则执行第二个构造器主体 4 ) 执行这个构造器的主体 this 类实例方法：引用方法的隐式参数 1234567class Cls &#123; private int a; public setA(int a) &#123; // this 隐式参数，调用 setA 方法的对象 this.a = a; &#125;&#125; 构造函数的第一条语句：调用同一个类的其他构造函数 123456789class Cls &#123; Cls() &#123; this("a", 3); //... &#125; Cls(String a, int b) &#123; //... &#125;&#125; 查找类文件假设类路径（class path）设置为 /home/user/classdir:.:/home/user/archives/archives.jar。 当要查找 com.domain.core.NewClass 类文件时 Java 虚拟机 jre/ lib 和 jre/lib/ext 目录下的归档文件中所存放的系统类文件 /home/user/classdir/com/domain/core/NewClass.class 从当前目录开始 com/domain/core/NewClass.class com/domain/core/NewClass.class inside /home/user/archives/archive.jar 编译器 确认导入的包中，是否有多个地方包含了类文件 检查源文件是否比类文件新，是否需要重新编译源文件生成类文件 文档注释以 /** 开始，以 */ 结束的多行注释。 每一行前面的 * 不是必须的。 注释采用自由格式文本（free-form text）： HTML 修饰符 强调 &lt;em&gt;...&lt;/em&gt; 着重强调 &lt;strong&gt;…&lt;/strong&gt; 图像 &lt;img…&gt; 等宽代码 {@code …} 分类 类注释 方法注释 变量描述 @param 返回值描述 @return 异常描述 @throws 域注释 只需要对公有域 （通常指的是静态常量）建立文档 通用注释 通用标记：以 @ 开头 @author @version @since @deprecated @see / @link 包与概述注释 第 5 章 继承一个对象变量可以指示多种实际类型的现象被称为多态 (polymorphism)。 在运行时能够自动地选择调用哪个方法的现象称为动态绑定 (dynamic binding)。 在 Java 中，不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征 ， 可以将它标记为 final 。 在 C++ 中需要声明虚函数。 动态绑定的限制 子类覆盖方法的返回值类型必须是超类方法的返回值的子类型（包括相同）。 覆盖方法的时候，子类方法不能低于超类方法的可见性。 final 修饰类：类不可被继承，类中的方法都成为 final 修饰方法：方法不可被子类覆盖 修饰域：数据域在初始化后不能再被修改 ​123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;class A &#123;public: void outA() &#123; puts("A.outA"); &#125; virtual void outA2() &#123; puts("A.outA2"); &#125;&#125;;class B: public A &#123;public: void outA() &#123; puts("B.outA"); &#125; void outA2() &#123; puts("B.outA2"); &#125; void outB() &#123; puts("B.outB"); &#125;&#125;;int main() &#123; A* a = new B(); a-&gt;outA(); a-&gt;outA2(); ((B*)a)-&gt;outB(); return 0;&#125;///A.outAB.outA2B.outB​ 访问修饰符 public 所有类可见 protected 本包和所有子类可见 ( ) default 本包可见 private 仅本类可见 Java 实现 equals 的一些基本要求 自反性：对于任何非空引用 x，x.equals(x) 应该返回 true 对称性：对于任何引用 x 和 y，当且仅当 x.equals(y) 返回 true，y.equals(x) 也应该返回 true 传递性：对于任何引用 x、y 和 z，如果 x.equals(y) 返回 true，且 y.equals(z) 返回 true，则 x.equals(z) 也应该返回 true 一致性：如果 x 和 y 引用的对象没有发生变化，反复调用 x.eqals(y) 应该返回同样的结果 对于任何非空引用 x，x.equals(null) 应该返回 false ​123456789101112131415161718192021222324252627282930313233343536public class TestExtends &#123; public static void main(String[] args) &#123; A a = new B(); a.outA(); ((B) a).outB(); System.out.println((a instanceof A) + ""); System.out.println((a instanceof B) + ""); System.out.println(a.getClass() == A.class); System.out.println(a.getClass() == B.class); &#125;&#125;class A &#123; public void outA() &#123; System.out.println("A.outA"); &#125;&#125;class B extends A &#123; @Override public void outA() &#123; System.out.println("B.outA"); &#125; public void outB() &#123; System.out.println("B.outB"); &#125;&#125;//B.outAB.outBtruetruefalsetrue​ 如何写 equals(Object otherObject) 显式参数命名为 otherObject, 稍后需要将它转换成另一个叫做 other 的变量。 检测 this 与 otherObject 是否引用同一个对象： if (this = otherObject) return true; 这条语句只是一个优化。 实际上， 这是一种经常采用的形式。 因为计算这个等式要比一 个一个地比较类中的域所付出的代价小得多。 检测 otherObject 是否为 null , 如果为 null , 返回 false。 这项检测是很必要的。 if (otherObject = null) return false; 比较 this 与 otherObject 是否属于同一个类。 如果 equals 的语义在每个子类中有所改变， 就使用 getClass 检测： if (getClass() != otherObject.getCIassO) return false; 如果所有的子类都拥有统一的语义， 就使用 instanceof 检测： if (!(otherObject instanceof ClassName)) return false; 将 otherObject 转换为相应的类类型变量： ClassName other = (ClassName) otherObject 现在开始对所有需要比较的域进行比较了。使用 == 比较基本类型域，使用 equals 比较对象域。如果所有的域都匹配，就返回 true; 否则返回 false。 12return fieldl == other.field &amp;&amp; Objects.equa1s(fie1d2, other.field2) 如果在子类中重新定义 equals, 就要在其中包含调用 super.equals(other) 函数可变个数参数 可变个数参数，应该是参数列表的最后一个参数 在函数中引用这些可变个数的参数时，以数组的形式来引用 除了传递不定个数的参数外，也可以用数组来传递给可变个数参数 ​123456789101112131415161718192021222324252627282930static void multipart(String s, int a, Object... values) &#123; System.out.println("s=" + s); System.out.println("a=" + a); System.out.println("values.getClass=" + values.getClass()); System.out.println("values instanceOf Object[] =" + (values instanceof Object[])); System.out.println(Arrays.toString(values)); System.out.println();&#125;multipart("string", 10, "one", 2, "three", 4.0);multipart("string", 10, new Object[]&#123;"one", 2, "three", 4.0&#125;);multipart("string", 10);///s=stringa=10values.getClass=class [Ljava.lang.Object;values instanceOf Object[] =true[one, 2, three, 4.0]s=stringa=10values.getClass=class [Ljava.lang.Object;values instanceOf Object[] =true[one, 2, three, 4.0]s=stringa=10values.getClass=class [Ljava.lang.Object;values instanceOf Object[] =true[]​ 枚举​123456789101112131415161718192021222324252627282930313233 public enum ProgramLanguage &#123; CPP("C++", 1), JAVA("Java", 2); private String lang; private int type; ProgramLanguage(String lang, int type) &#123; this.lang = lang; this.type = type; &#125; public static ProgramLanguage valueOf(int type) &#123; switch (type) &#123; case 1: return CPP; case 2: return JAVA; default: return null; &#125; &#125; &#125; ProgramLanguage language; language = ProgramLanguage.CPP; System.out.println(language); language = ProgramLanguage.valueOf(1); System.out.println(language); language = ProgramLanguage.valueOf("CPP"); System.out.println(language); language = Enum.valueOf(ProgramLanguage.class, "CPP")​ Class 类对象程序运行期间， Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识。 这个信息跟踪着每个对象所属的类。 虚拟机利用运行时类型信息选择相应的方法执行。 然而，可以通过专门的 Java 类访问这些信息。保存这些信息的类被称为 Class, 这个名字很容易让人混淆。 ​123456789ClassName obj = new ClassName();1. obj.getClass();2. Class.forName(ClassName);3. ClassName.class​ 一个 Class 对象实际上表示的是一个类型， 而这个类型未必一定是一种类。 例如， int 不是类， 但 int.class 是一个 Class 类型的对象。 在启动时， 包含 main 方法的类被加载。 它会加载所有需要的类。 这些被加栽的类又要加载它们需要的类。 反射java.lang.reflect Field：域 getName getModifiers getType Method：方法 getName getModifiers getParameterTypes getReturnType Constructor：构造器 getName getModifiers getParameterTypes java.lang.class getFields getMethods getConstructors 第 6 章 接口、lambda 表达式与内部类接口 方法自动被设置为 public 域自动被设置为 public static final JDK 8，可以有静态方法 可以为接口提供一个默认实现，使用 default 接口中有很多个方法，可以都有默认实现。使用接口时，只需要覆盖其中关心的方法即可，无需每个方法都手动写一个“空实现” 接口增加方法后，原有的实现类不用实现新方法，仍可使用 标记接口 tagging interface / 记号接口 marker interface标记接口不包含任何方法；它唯一的作用就是允许在类型查询中使用 instanceof。比如 Cloneable。clone 方法中，调用域的 clone 方法时，需要判断相应的域是否为 null。 ​123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package test.zz;/** * TestClone * * @author zz * @date 2018/5/28 */public class TestClone &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Clone2 clone2 = new Clone2(); Clone2 clone21 = clone2.clone(); &#125;&#125;class Addr implements Cloneable &#123; @Override public Addr clone() throws CloneNotSupportedException &#123; System.out.println("Addr.clone - 1"); return (Addr) super.clone(); &#125;&#125;class Clone1 implements Cloneable &#123; private String name; private Addr addr; Clone1() &#123; &#125; Clone1(String name) &#123; this.name = name; this.addr = new Addr(); &#125; @Override public String toString() &#123; return "&#123; name:" + name + ", addr:" + addr + " &#125;"; &#125; @Override public Clone1 clone() throws CloneNotSupportedException &#123; System.out.println("Clone1.clone - 1"); Clone1 clonee = (Clone1) super.clone(); clonee.addr = addr == null ? null : addr.clone(); //////// !!!!!!!!!!! System.out.println("Clone1.clone - 2"); return clonee; &#125;&#125;class Clone2 extends Clone1 implements Cloneable &#123; private Clone1 clone1; @Override public Clone2 clone() throws CloneNotSupportedException &#123; System.out.println("Clone2.clone - 1"); return (Clone2) super.clone(); &#125;&#125;​ 所有数组类型都有一个 public 的 clone 方法， 而不是 protected: 可以用这个方法 建立一个新数组， 包含原数组所有元素的副本。 lambda 表达式lambda 表达式是一个可传递的代码块， 可以在以后执行一次或多次。 带参数变量的表达式就被称为 lambda 表达式。 形式上参数，箭头，表达式 (params…) -&gt; { code block } 括号 参数仅有一个，且类型可被自动推导出来，可省略括号和类型 参数不是一个（包括 0 个），不能省略括号 若类型可被自动推导出来，可省略。 代码块 仅有一条语句，可省略大括号 返回值 代码块中的最后一条语句会作为返回值返回（无需显式使用 return） 如果代码块中存在分支（if else），每个分支都必须有返回值 返回值类型会自动推导，无需指定 定义上 一个代码块 参数 自由变量的值，非参数而且不在代码块中定义的变量 lambda 表达式中捕获的变量必须实际上是最终变量 ( effectively final 。) 实际上的最终变量是指， 这个变量初始化之后就不会再为它赋新值。 函数式接口对于只有一个抽象方法的接口， 需要这种接口的对象时， 就可以提供一个 lambda 表达 式。 这种接口称为函数式接口 (functional interface )。 lambda 表达式最终会被转换为函数式接口。本质上是函数式接口的简写，一个语法糖。 使用​1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package test.zz;import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;/** * TestTimer * * @author zz * @date 2018/5/28 */public class TestTimer &#123; public static void main(String[] args) throws InterruptedException &#123; ActionListener listener; Timer timer; listener = new TimerPrinter(); timer = new Timer(1000, listener); timer.start(); Thread.sleep(5000); timer.stop(); listener = new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println("[[2]] actionPerformed.event=" + e); &#125; &#125;; timer = new Timer(1000, listener); timer.start(); Thread.sleep(5000); timer.stop(); listener = event -&gt; &#123; System.out.println("[[3]] actionPerformed.event=" + event); &#125;; timer = new Timer(1000, listener); timer.start(); Thread.sleep(5000); timer.stop(); &#125;&#125;interface Func &#123; void test(String s, int b);&#125;class TimerPrinter implements ActionListener &#123; @Override public void actionPerformed(ActionEvent event) &#123; System.out.println("[[1]] actionPerformed event=" + event); &#125;&#125;////////[[1]] actionPerformed event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571207103,modifiers=] on javax.swing.Timer@266267b2[[1]] actionPerformed event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571208108,modifiers=] on javax.swing.Timer@266267b2[[1]] actionPerformed event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571209112,modifiers=] on javax.swing.Timer@266267b2[[1]] actionPerformed event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571210113,modifiers=] on javax.swing.Timer@266267b2[[2]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571212097,modifiers=] on javax.swing.Timer@225de7a6[[2]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571213101,modifiers=] on javax.swing.Timer@225de7a6[[2]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571214104,modifiers=] on javax.swing.Timer@225de7a6[[2]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571215106,modifiers=] on javax.swing.Timer@225de7a6[[3]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571217104,modifiers=] on javax.swing.Timer@3b912d4a[[3]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571218108,modifiers=] on javax.swing.Timer@3b912d4a[[3]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571219111,modifiers=] on javax.swing.Timer@3b912d4a[[3]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571220114,modifiers=] on javax.swing.Timer@3b912d4a​ 这里参数的本质是一个接口，有几种方式实现： 定义一个类实现该接口，实例化一个该类的对象作为参数 定义一个匿名类，直接在参数处定义该类 当接口中仅有一个抽象方法时，可使用 lambda 表达式的形式 有时候，并不需要定义新的 lambda 表达式，而是使用已有的类方法。 object::instanceMethod Class::static Method Class::instanceMethod ​123456789aString::compareTo == x -&gt; aString.compareTo(x)this::equals == x -&gt; this.equals(x)System.out::prinrln == x -&gt; System.out.println(x)Math::pow == (x, y) -&gt; Math.pow(x, y)String::equals == (x, y) -&gt; x.equals(y)​ 函数式接口只有一个抽象方法的接口，使用 @FunctionalInterface 标记 如果无意中增加了一个非抽象方法，编译器会产生一个错误消息 javadoc 文档会指出这个接口是一个函数式接口 第 7 章 异常、断言和日志捕获还是抛出异常 知道如何处理异常，就应该捕获 不知道怎样处理，就抛出异常继续传递 子类方法抛出的异常不能超过父类方法声明的范围 异常继承​1234567891011 Throwable | +------------+------------+ | | Error Exception (uncheckd exception) | +------------+------------+ | | RuntimeException other excpetion (uncheckd) (checked)​]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>旧文补发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Spring Boot 中使用 Redis]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%9C%A8-Spring-Boot-%E4%B8%AD%E4%BD%BF%E7%94%A8-Redis%2F</url>
    <content type="text"><![CDATA[在 Spring Boot 中 使用 Redis本文中的代码见 spring-boot-redis。 Redis 本身的一些概念Redis 支持的数据结构 String 字符串 Hash 字典 List 列表 Set 集合 Sorted Set 有序集合 String 和 Hash 的对比String 实际是就是一个 Key - Value 的映射； Hash 就是一个 Key - （Key - Value） 的两层映射。 12345678910111213# redis-cli# Redis 中命令不区分大小写。这里命令使用小写，仅在特别的地方用大写。# 参数使用“大写+下划线”的方式。# Stringset KEY VALUEget KEY# Hashhset HASH_NAME KEY VALUEhget HASH_NAME KEYhMset HASH_NAME KEY0 VALUE0 KEY1 VALUE1 ...hMget HASH_NAME KEY0 KEY1 ... STACK OVERFLOW 上一个对 String 和 Hash 的讨论 对于一个对象是把本身的数据序列化后用 String 存储，还是使用 Hash 来分别存储对象的各个属性： 如果在大多数时候要访问对象的大部分数据：使用 String 如果在大多数时候只要访问对象的小部分数据：使用 Hash 如果对象里面还有对象这种结构复杂的，最好用 String。否则最外层用 Hash，里面又将对象序列化，两者混用可能导致混乱。 Spring Boot 添加 Redis 的配置 以 gradle 为例。 修改 build.gradle 1compile(&quot;org.springframework.boot:spring-boot-starter-data-redis&quot;) 修改 application.yml 123456789101112131415161718spring: # redis redis: ​ host: 127.0.0.1 ​ # 数据库索引（默认为0） ​ database: 0 ​ port: 6379 ​ password: PASSWORD ​ # 连接池中的最大空闲连接 ​ pool.max-idle: 8 ​ # 连接池中的最小空闲连接 ​ pool.min-idle: 0 ​ # 连接池最大连接数（使用负值表示没有限制） ​ pool.max-active: 8 ​ # 连接池最大阻塞等待时间（使用负值表示没有限制） ​ pool.max-wait: -1 ​ # 连接超时时间（毫秒） ​ timeout: 0 添加 RedisConfig 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package zz.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.extern.slf4j.Slf4j;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;/** * RedisConfig * * @author zz * @date 2018/5/7 */@Configuration@EnableCaching@Slf4jpublic class RedisConfig extends CachingConfigurerSupport &#123; @Bean public KeyGenerator wiselyKeyGenerator() &#123; ​ return new KeyGenerator() &#123; ​ private static final String SEPARATE = ":"; @Override public Object generate(Object target, Method method, Object... params) &#123; log.debug("+++++generate"); StringBuilder sb = new StringBuilder(); sb.append(target.getClass().getName()); sb.append(SEPARATE).append(method); for (Object obj : params) &#123; sb.append(SEPARATE).append(obj); &#125; return sb.toString(); &#125; &#125;; &#125; /** * https://www.jianshu.com/p/9255b2484818 * * TODO: 对 Spring @CacheXXX 注解进行扩展：注解失效时间 + 主动刷新缓存 */ @Bean public CacheManager cacheManager(@SuppressWarnings("rawtypes") RedisTemplate redisTemplate) &#123; log.debug("++++cacheManager"); RedisCacheManager redisCacheManager =new RedisCacheManager(redisTemplate); redisCacheManager.setTransactionAware(true); redisCacheManager.setLoadRemoteCachesOnStartup(true); // 最终在 Redis 中的 key = @Cacheable 注解中 'cacheNames' + 'key' redisCacheManager.setUsePrefix(true); // 所有 key 的默认过期时间，不设置则永不过期 // redisCacheManager.setDefaultExpiration(6000L); // 对某些 key 单独设置过期时间 // 这里的 key 是 @Cacheable 注解中的 'cacheNames' Map&lt;String, Long&gt; expires = new HashMap&lt;&gt;(10); // expires.put("feedCategoryDto", 5000L); // expires.put("feedDto", 5000L); redisCacheManager.setExpires(expires); return redisCacheManager; &#125; // value serializer private Jackson2JsonRedisSerializer getJackson2JsonRedisSerializer() &#123; Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); return jackson2JsonRedisSerializer; &#125; private GenericJackson2JsonRedisSerializer getGenericJackson2JsonRedisSerializer() &#123; return new GenericJackson2JsonRedisSerializer(); &#125; /** * * Once configured, the template is thread-safe and can be reused across multiple instances. * -- https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/ */ @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123; log.debug("++++redisTemplate"); StringRedisTemplate template = new StringRedisTemplate(factory); // key serializer StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); RedisSerializer valueRedisSerializer; // -- 1 Jackson2JsonRedisSerializer // valueRedisSerializer = getJackson2JsonRedisSerializer(); // -- 2 GenericJackson2JsonRedisSerializer valueRedisSerializer = getGenericJackson2JsonRedisSerializer(); // set serializer template.setKeySerializer(stringRedisSerializer); template.setValueSerializer(valueRedisSerializer); template.setHashKeySerializer(stringRedisSerializer); template.setHashValueSerializer(valueRedisSerializer); template.afterPropertiesSet(); return template; &#125;&#125; RedisConfig 中定义了三个函数，主要作用如下： wiselyKeyGenerator：定义了一个生成 Redis 的 key 的方法。如下文使用了 @Cacheable 注解的地方，可以指定 key 的生成方法使用我们这个函数。 cacheManager：定义了对 Redis 的一些基本设置。 redisTemplate：对我们要使用的 RedisTemplate 做一些设置。主要是确定序列化方法。 RedisTemplate 设置序列化器Spring Redis 虽然提供了对 list、set、hash 等数据类型的支持，但是没有提供对 POJO 对象的支持，底层都是把对象序列化后再以字节的方式存储的。 因此，Spring Data Redis 提供了若干个 Serializer，主要包括： JdkSerializationRedisSerializer： 默认的序列化器。序列化速度快，生成的字节长度较大。 OxmSerializer： 生成 XML 格式的字节。 StringSerializer： 只能对 String 类型进行序列化。 JacksonJsonRedisSerializer：以 JSON 格式进行序列化。 Jackson2JsonRedisSerializer：JacksonJsonRedisSerializer 的升级版。 GenericJackson2JsonRedisSerializer：Jackson2JsonRedisSerializer 的泛型版。 RedisTemplate 中需要声明 4 种 serializer（默认使用的是 JdkSerializationRedisSerializer）： keySerializer ：对于普通 K-V 操作时，key 采取的序列化策略 valueSerializer：value 采取的序列化策略 hashKeySerializer： 在 hash 数据结构中，hash-key 的序列化策略 hashValueSerializer：hash-value 的序列化策略 无论如何，建议 key/hashKey 采用 StringRedisSerializer。 by Spring-data-redis: serializer实例 我们设置了 serializer 后，读写 Redis 要使用同一种 serizlizer，否则会读不出之前用不同 serializer 写入的数据。 也就是设置 valueSerializer 为GenericJackson2JsonRedisSerializer，然后写入了数据。后面要读数据的时候，如果将 valueSerializer 又设置成了 Jackson2JsonRedisSerializer，那么读取数据时就会报错。 通常情况下，我们只需要在 RedisConfig 中统一设置好 4 个 serializer 即可。 Jackson2JsonRedisSerializer 与 GenericJackson2JsonRedisSerializer 的对比 两者都是将对象的数据序列化成 JSON 格式的字符串。 Jackson2JsonRedisSerializer 需要自己指定 ObjectMaper 或某个特定的类型。 GenericJackson2JsonRedisSerializer 是 Jackson2JsonRedisSerializer 的一个特例，默认支持所有类型。 两者序列化时，都会将原始对象的类名和包名写入 JSON 字符串中。以便反序列化时，确认要将 JSON 转成何种格式。 可用如下方式来获得通用的 Jackson2JsonRedisSerializer12345678Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = ​ new Jackson2JsonRedisSerializer(Object.class);ObjectMapper om = new ObjectMapper();om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);jackson2JsonRedisSerializer.setObjectMapper(om); Jackson2JsonRedisSerializer 与 GenericJackson2JsonRedisSerializer 生成 JSON 的对比12345# Jackson2JsonRedisSerializer 序列化的效果127.0.0.1:6379&gt; get 123&quot;[\&quot;zz.domain.User\&quot;,&#123;\&quot;id\&quot;:123,\&quot;name\&quot;:\&quot;name\&quot;&#125;]&quot;127.0.0.1:6379&gt; get userList&quot;[\&quot;java.util.LinkedList\&quot;,[[\&quot;zz.domain.User\&quot;,&#123;\&quot;id\&quot;:233,\&quot;name\&quot;:\&quot;new\&quot;&#125;],[\&quot;zz.domain.User\&quot;,&#123;\&quot;id\&quot;:233,\&quot;name\&quot;:\&quot;new\&quot;&#125;]]]&quot; 12345# GenericJackson2JsonRedisSerializer 序列化的效果127.0.0.1:6379&gt; get 123&quot;&#123;\&quot;@class\&quot;:\&quot;zz.domain.User\&quot;,\&quot;id\&quot;:123,\&quot;name\&quot;:\&quot;name\&quot;&#125;&quot;127.0.0.1:6379&gt; get userList&quot;[\&quot;java.util.LinkedList\&quot;,[&#123;\&quot;@class\&quot;:\&quot;zz.domain.User\&quot;,\&quot;id\&quot;:233,\&quot;name\&quot;:\&quot;new\&quot;&#125;,&#123;\&quot;@class\&quot;:\&quot;zz.domain.User\&quot;,\&quot;id\&quot;:233,\&quot;name\&quot;:\&quot;new\&quot;&#125;]]&quot; 如何使用使用注解来缓存函数的结果在要缓存的方法上使用注解 @Cacheable、@CachePut、@CacheEvict 分别用于缓存返回数据、更新缓存数据、删除缓存数据。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package zz.service;import lombok.extern.slf4j.Slf4j;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.CachePut;import org.springframework.cache.annotation.Cacheable;import org.springframework.stereotype.Service;import zz.domain.User;/** * UserService * * @author zz * @date 2018/5/7 */@Service@Slf4jpublic class UserService &#123; public final String DEFAULT_NAME = "def"; @Cacheable(cacheNames = "user", key = "'id_'+#userId") public User get(int userId) &#123; ​ // get from db ​ log.debug("[++] get userId=" + userId); User user = new User(); user.setId(userId); user.setName(DEFAULT_NAME); log.debug("[++] create default user=" + user); return user; &#125; @CachePut(cacheNames = "user", key = "'id_'+#user.getId()") public User update(User user) &#123; ​ // save to db ​ log.debug("[++] update user=" + user); ​ return user; &#125; @CacheEvict(cacheNames = "user", key = "'id_'+#userId") public void delete(int userId) &#123; ​ // delete from db ​ log.debug("[++] delete userId=" + userId); &#125; @CachePut(cacheNames = "user", key = "'id_'+#userId") public User updateName(int userId, String name) &#123; ​ // update to db ​ log.debug("[++] updateName userId=" + userId + ", name=" + name); User user = get(userId); user.setName(name); return user; &#125; public void innerCall(int userId) &#123; ​ log.debug("[++] innerCall"); ​ get(userId); &#125;&#125; 对函数的缓存是通过代理来实现的 ：类内部的某个函数对其他函数（即便被调用函数有 @CacheXXX 注解）的调用是不会走代理的，也就没有缓存。(比如 innerCall 调用 get 时不会使用缓存) 。 注解可以放到 Service、Dao 或 Controller 层。 @CacheXXX 会缓存函数的返回值。比如 increaseComment 会缓存更新后的 FeedCount。 当缓存中有数据时，@Cacheable 注解的函数不会执行，直接返回缓存中的数据。 @CachePut、@CacheEvit 注解的函数，无论如何都会执行。 自定义缓存如果要更细粒度地控制 Redis，可以使用 RedisTemplate、StringRedisTemplate StringRedisTemplate 是 RedisTemplate 的一个特例：key 和 value 都是 String 类型。 RedisTemplate 默认使用 JDK 对 key 和 value 进行序列化，转成字节存入 Redis。 StringRedisTemplate 的 key、value 本身就是 String，使用 StringRedisSerializer 将 String 转成字节存入 Redis。 当我们将 RedisTemplate 的 keySerializer 和 valueSerializer 都设置成了 StringRedisSerializer，则 RedisTemplate 和 StringRedisTemplate 的效果是相同的，就像下面的样例所示。 RedisTemplate 对 Redis 中各个数据结构的操作 redisTemplate.opsForValue();//操作字符串 redisTemplate.opsForHash();//操作hash redisTemplate.opsForList();//操作list redisTemplate.opsForSet();//操作set redisTemplate.opsForZSet();//操作有序set 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160package zz;import lombok.extern.slf4j.Slf4j;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import org.springframework.test.context.junit4.SpringRunner;import zz.domain.User;import zz.service.UserService;import java.util.LinkedList;import java.util.List;/** * zz.TestRedis * * @author zz * @date 2018/5/7 */@SpringBootTest@RunWith(SpringRunner.class)@Slf4jpublic class TestRedis &#123; @Autowired StringRedisTemplate stringRedisTemplate; @Autowired RedisTemplate redisTemplate; @Autowired UserService userService; @Test public void testSerializer() &#123; // 1. // 这里的 opsForValue().get() 的参数必须转成 String 类型。 // 除非在 RedisConfig 中 将 keySerializer 设置成 GenericJackson2JsonRedisSerializer 等能将其他类型转换成 String 的。 // 2. // 如果切换了 RedisConfig 中的 ValueSerializer，要先用 redis-cli 将其中的旧数据删除。 // 不同 Serializer 格式之间的转换可能存在问题。 final int ID = 123; User oldUser; oldUser = (User) redisTemplate.opsForValue().get(String.valueOf(ID)); log.debug("oldUser=" + oldUser); User user = new User(); user.setId(ID); user.setName("name"); log.debug("user=" + user); redisTemplate.opsForValue().set(String.valueOf(user.getId()), user); User newUser; newUser = (User) redisTemplate.opsForValue().get(String.valueOf(ID)); log.debug("newUser=" + newUser); Assert.assertEquals(user.getId(), newUser.getId()); Assert.assertEquals(user.getName(), newUser.getName()); List&lt;User&gt; userList = new LinkedList&lt;&gt;(); userList.add(user); user.setId(233); user.setName("new"); userList.add(user); redisTemplate.opsForValue().set("userList", userList); List&lt;User&gt; newUserList; newUserList = (List&lt;User&gt;) redisTemplate.opsForValue().get("userList"); Assert.assertEquals(userList, newUserList); &#125; @Test public void testSerizlizer2() &#123; // 保存用于恢复，以免影响其他部分 RedisSerializer oldKeySerializer = redisTemplate.getKeySerializer(); RedisSerializer oldValueSerializer = redisTemplate.getValueSerializer(); RedisSerializer redisSerializer = new StringRedisSerializer(); redisTemplate.setKeySerializer(redisSerializer); redisTemplate.setValueSerializer(redisSerializer); final String KEY = "key"; String VALUE = "value"; redisTemplate.opsForValue().set(KEY, VALUE); Assert.assertEquals(VALUE, redisTemplate.opsForValue().get(KEY)); Assert.assertEquals(VALUE, stringRedisTemplate.opsForValue().get(KEY)); VALUE = "Val2"; stringRedisTemplate.opsForValue().set(KEY, VALUE); Assert.assertEquals(VALUE, stringRedisTemplate.opsForValue().get(KEY)); Assert.assertEquals(VALUE, redisTemplate.opsForValue().get(KEY)); // 恢复原本设置 redisTemplate.setKeySerializer(oldKeySerializer); redisTemplate.setValueSerializer(oldValueSerializer); &#125; @Test public void testCache() &#123; final int USER_ID = 1; User user = userService.get(USER_ID); log.debug("user=" + user); Assert.assertEquals(userService.DEFAULT_NAME, user.getName()); // 这次会直接返回 cache user = userService.get(USER_ID); log.debug("user=" + user); // 获得修改过的 cache final String ANOTHER_NAME = "another user"; user.setName(ANOTHER_NAME); userService.update(user); user = userService.get(USER_ID); log.debug("user=" + user); Assert.assertEquals(ANOTHER_NAME, user.getName()); // 直接调用 get 会走缓存，通过 innerCall 来调用 get 不会走缓存 log.debug("------ before"); userService.get(USER_ID); log.debug("------ middle"); userService.innerCall(USER_ID); log.debug("------ after"); // 另一种修改的方式 final String NEW_NAME = "updated"; userService.updateName(USER_ID, NEW_NAME); user = userService.get(USER_ID); log.debug("user=" + user); Assert.assertEquals(NEW_NAME, user.getName()); // 删除后，cache 中的数据会被删除，name 会变成初始值 userService.delete(USER_ID); user = userService.get(USER_ID); log.debug("user=" + user); Assert.assertEquals(userService.DEFAULT_NAME, user.getName()); // 即使 cache 中没有该数据，也会执行 delete 中的逻辑 userService.delete(USER_ID); userService.delete(USER_ID); &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>旧文补发</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗讲解 HTTPS]]></title>
    <url>%2F2018%2F04%2F28%2F%E9%80%9A%E4%BF%97%E8%AE%B2%E8%A7%A3-HTTPS%2F</url>
    <content type="text"><![CDATA[通俗讲解 HTTPS为什么要用 HTTPSHTTP 是明文传输，任何人都能窃听到，甚至篡改。 HTTPS 可以有效防止窃听和篡改，能极大提高网站的安全性。 HTTPS 如何保障安全性加密传输数据HTTPS 会先将数据进行加密再传输，在网络中传输的时候任何人都只能捕获到加密后的数据。而只有拥有相应的秘钥才能解开数据。 那这里就有了新的问题：数据要怎么加密，用哪种加密方法来加密，客户端和服务端怎么协商确定秘钥，同时保证秘钥不被第三方所知道。 对称加密与非对称加密先简单介绍两种加密的方式：对称加密和非对称加密。 顾名思义，对称加密就是加密和解密时使用的是相同的秘钥，优点是速度快。缺点是任意两个通信的实体之间都要维护他们彼此间通信的秘钥，而维护这么多的秘钥的成本太大了。 非对称加密就是加密和解密使用的是不同的秘钥，分别称之为公钥和私钥。公钥可以公开出来让所有人知道；私钥必须保存好，不能让其他人知道。非对称加密的特点是用公钥加密的数据只能用私钥解密，用私钥加密的数据只能用公钥解密。缺点是速度慢。 于是，我们可以这样操作：​123456789客户端随机生成一个秘钥 A，使用服务端的公钥加密后发送给服务端。服务端收到后，用自己的私钥进行解密获得 A。服务端告诉客户端自己已经获得了 A。这样客户端和服务端就都得到了一个秘钥 A，且不为其他人所知。秘钥 A 只在本次通信过程中有效。随后客户端每次发送数据前，都用秘钥 A 进行对称加密，服务端收到后都用秘钥 A 进行解密。服务端发送数据给客户端时，也采用类似的操作。​ 通过这样的操作，我们利用非对称加密来达到协商和确定好对称加密的秘钥 A，同时又利用了对称加密速度快的特点。 实际上 HTTPS 协商秘钥 A 的过程会比这个更复杂。但本质都是利用非对称加密来达到协商的目的。 这里实际上就有了一个新的问题：客户端怎么拿到服务端的公钥，同时确保这就是服务端的公钥而不是其他人伪造的。 HTTPS 证书当我们访问一个 HTTPS 的网站时，服务端会下发一个 HTTPS 证书给我们。证书里面就包含了服务端的公钥，同时还有其他信息：证书所属的域名、颁发的机构、何时生效、何时过期等。 那现在问题就是我们如何确认一个证书是不是有效的，而且是不是我们访问的服务端发给我们的。 这里就牵扯到了 HTTPS 证书的生成。 简单说明一下 CA（证书颁发机构），CA 专门管理证书的申请和颁发。 申请证书的过程如下：​1234567891011121314151617服务端向 CA 申请自己的 HTTPS 证书，CA 审核通过后，就会将服务端的域名、公钥、证书的有效期等信息写到证书里。同时 CA 会对证书里的信息做一个哈希获得一个哈希值，用自己的秘钥对这个哈希值进行加密获得一个加密串，并把加密串也写到证书里。这一过程称之为签名。（签名就是证明这证书的确是 CA 发的，CA 为证书进行背书。）现在，当我们访问网站后收到一个证书时，首先用 CA 的公钥对加密串进行解密，得到加密前的哈希值。再对证书本身的数据做一个哈希，如果这两个哈希值是一致的说明证书有效。同时还要注意证书是否在有效期内。通过以上校验，我们就可以认为这的确是我们期望的服务端下发的证书。假设有人伪造了证书，假装自己是服务端，由于他没有 CA 的秘钥，也就无法构造出与伪造数据吻合的加密串。我们只要用 CA 的公钥对加密串一解密，发现哈希值不一致，就可以认定这是伪造的。​ 这里又牵出了新的问题：我们怎么拿到 CA 的公钥。 全球只有为数不多的几个顶级 CA 有资格进行 HTTPS 证书的颁发。 所以操作系统和浏览器会预装这些 CA 的证书（包含了 CA 的公钥）。也就省去我们获取 CA 公钥的步骤和获取过程可能存在的伪造。 这里也可以看出 CA 证书是多么重要。如果我们电脑中安装了恶意的 CA 证书，而这个 CA 又故意或无意签发了大量恶意服务端的证书，那我们即便使用了 HTTPS 也无法保证安全通信。 客户端证书大部分时候，我们都是从服务端拿数据，所以主要保证服务端是我们要访问的，也就是服务端要配置 HTTPS 证书。 如果为了让服务端确认客户端的确是谁，在大多数情况下使用“账号+密码”或“手机号+短信验证码”已经足够了。 为每个客户端都配置 HTTPS 证书，一个是申请证书本身需要费用；一个是申请的门槛较高，不是每个用户都能做到。 也因此，只要服务端配置了 HTTPS 证书，在大多数情况下已经足够安全了。 但是，对于某些对安全性要求极高的网站来说，他们也会要求客户端要安装 HTTPS 证书。 比如银行网上转账就是一个十分敏感的操作。通常在我们申请银行卡的时候会得到一个 U 盾。 U 盾里面实际上也是一个 HTTPS 证书，用于证明“我就是我”。 只是这个证书是由银行自己颁发的。（实际上要像 CA 那样发布证书是很容易的，但是只有少数权威的 CA 才被操作系统和浏览器所认可。） 当我们要进行网上转账的时候，就必须把 U 盾插入到电脑上，访问银行的相关网站时，就会把 U 盾中的证书带上去。 银行的服务端在收到我们的证书，就用自己的私钥进行解密，也就能确认我们的身份了。 Ref深入浅出 HTTPS]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>旧文补发</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 编译与链接]]></title>
    <url>%2F2017%2F08%2F27%2FLinux-%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[Linux 下 C/C++ 代码编译链接生成可执行程序的过程，主要包括如下几个步骤。 预处理12#只进行预处理并把预处理结果输出g++ -E source.cpp -o source.i 预处理过程主要处理源代码文件中以 # 开始的预编译指令，包括如下规则。 将所有的 #define 删除，并且展开所有的宏定义。 处理所有的条件预编译指令，包括 #if、 #ifdef、 #ifndef、 #elif、 #else、 #endif 等。 处理 #include 预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件，也会同样被插入。 过滤所有的注释中的内容，包括 // 和 /* */。 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。 保留所有的 #pragma 编译器指令，因为编译器需要使用它们。 编译12#输出编译后的汇编代码文件g++ -S source.i -o source.s 编译过程就是把预处理完的文件进行如下的一系列操作后产生相应的汇编代码文件。这个过程往往是整个程序构建的核心部分，也是最复杂的部分之一。 词法分析 语法分析 语义分析 源代码优化 代码生成 目标代码优化这里不展开一一赘述。 通过如下命令，我们可以直接从源文件得到目标文件/中间代码文件，如 .o 文件。 12#只编译不链接g++ -c source.cpp 链接各个源代码模块独立地编译成目标文件，链接就是把这些目标文件和库链接形成可执行文件的过程。这里的“库”指的是：一组目标文件的包，也就是将一些常用的代码编译成目标文件后打包存放，便于使用。链接分为静态链接和动态链接。 静态链接对函数库的链接是放在编译时期完成的是静态链接。静态库文件命名格式为：libNAME.a 。有如下 5 个文件： 12345//add.h#ifndef _ADD_H_#define _ADD_H_int add(int a, int b);#endif 123456//add.cpp#include "add.h"int add(int a, int b)&#123; return a + b;&#125; 12345//sub.h#ifndef _SUB_H_#define _SUB_H_int sub(int a, int b);#endif 123456//sub.cpp#include "sub.h"int sub(int a, int b)&#123; return a - b;&#125; 1234567891011//main.cpp#include "add.h"#include "sub.h"#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "1+2=" &lt;&lt; add(1, 2) &lt;&lt; endl; cout &lt;&lt; "1-2=" &lt;&lt; sub(1, 2) &lt;&lt; endl; return 0;&#125; 生成静态库并链接形成可执行文件的过程如下：将 add.cpp 和 sub.cpp 编译成 .o 文件12g++ -c add.cppg++ -c sub.cpp 由 .o 文件创建静态库1ar cr libmymath.a sub.o add.o 链接静态库并生成可执行文件 main123# -L 额外指定库搜索路径# -l 额外指定链接的库g++ -o main main.cpp -L. -lmymath ar 命令用于创建和维护库文件。 c 选项：不管是否已存在，创建一个库。 r 选项： 在库中插入或替换模块。 tv 选项： 显示库中有哪些目标文件，显示文件名、时间、大小等详细信息。 运行1./main 动态链接对库函数的链接载入推迟到程序运行时期就是动态链接。动态库文件命名格式为：libNAME.so 。同样以上面的 5 个文件为例。 如果你边跟着本文顺序，边在动手实践的话，此时请暂时将静态库文件 libmymath.a 删除或重命名成其他名字。减少干扰。 生成动态库并链接形成可执行文件的过程如下：生成动态库1234567# 1.g++ -fPIC -o add.o -c add.cppg++ -fPIC -o sub.o -c sub.cppg++ -shared -o libmymath.so add.o sub.o# 或者# 2.g++ -fPIC -shared -o libmymath.so add.cpp sub.cpp -fPIC 编译为位置独立的代码。 生成目标文件1g++ -o main main.cpp -L. -lmymath 运行1./main CentOS 等 Linux 系统下直接运行会报错./main: error while loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory 使用 ldd 命令来查看目标文件shell ldd main shell linux-vdso.so.1 =&gt; (0x00007ffefc135000) libmymath.so =&gt; not found libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007ff6d629e000) libm.so.6 =&gt; /lib64/libm.so.6 (0x00007ff6d5f9c000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007ff6d5d86000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007ff6d59c4000) /lib64/ld-linux-x86-64.so.2 (0x00007ff6d65af000) 这是因为系统运行 main 时，会按照如下顺序搜索动态库： 编译目标代码时指定的动态库搜索路径 环境变量 LD_LIBRARY_PATH 指定的动态库搜索路径 配置文件 /etc/ld.so.conf 中指定的动态库搜索路径 默认的动态库搜索路径 /lib 默认的动态库搜索路径 /usr/lib也就找不到我们生成的 libmymath.so 。 相应地有以下几种方法可以告诉系统如何找到我们需要的动态库。 编译时增加 -Wl,-rpath来指定额外的动态库搜索路径。当指定多个动态库搜索路径时，路径之间用冒号 ： 分隔。shell g++ -o main main.cpp -L. -lmymath -Wl,-rpath=. 修改环境变量 LD_LIBRARY_PATHshell export LD_LIBRARY_PATH=/PATH_TO_LIB:$LD_LIBRARY_PATH 修改配置文件 /etc/ld.so.conf sudo vi /etc/ld.so.conf将动态库所在路径添加到 ld.so.conf 中PATH_TO_LIB使修改生效sudo ldconfig 将我们的库添加到默认路径中 1234567sudo cp libmymath.so /usr/lib# 或sudo cp libmymath.so /lib# 如果复制后还是找不到动态库文件，可执行下述命令，详情请看 参考里的 ldconfig 详解# sudo ldconfig MacOS 下系统会自动在目标文件所在路径寻找动态库文件，所以可以直接运行不会报错。Mac 下没有 ldd命令， 可通过 otool -L来查看目标文件的依赖。 1otool -L main 1234main: libmymath_one.so (compatibility version 0.0.0, current version 0.0.0) /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.5.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.60.2) 动态库和静态库同名问题以上述文件为例，我们在同一目录中分别执行命令生成动态库和静态库，即 libmymath.so和 libmymath.a。此时执行 g++ -o main main.cpp -L. -lmymath，然后运行目标文件 ./main，会看到./main: error while loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory也就是说编译器优先采用了动态链接来生成目标文件：首先到path目录下搜索 libXXX.so动态库文件，如果没有找到，才会搜索 libXXX.a静态库文件。 动态库与静态库的对比 动态库 有利于进程间资源共享，减少资源占用。 方便升级。只要接口不变，程序无需重新编译。 链接载入完全由程序员在程序代码中控制。 静态库 执行速度快。 编译后静态库已打包在目标文件中，减少了依赖。 g++ 与 gcc 的对比 g++ 和 g++ 都可以编译 C++ 代码。在编译阶段 g++ 会自动调用 gcc ，两者是等价的。 后缀为 .c 的代码， gcc 把它当作是 C 程序， 而 g++ 当作 C++ 程序；后缀为 .cpp 的，两者都会将其当作 C++ 程序。 链接可以用 g++ 或 gcc-lstdc++ 。 gcc 命令不能自动和 C++ 程序使用的库链接。 __cplusplus宏标志着编译器会把代码按 C 还是 C++ 语法来解释。对于 g++ 来说，该宏都会定义；对于 gcc 来说，该宏是否定义取决于文件后缀。 以下述 .c 文件为例。 123456789101112#source.c#include &lt;stdio.h&gt;int main()&#123;#ifdef __cplusplus printf("define __cplusplus\n");#else printf("undefine __cplusplus\n");#endif return 0;&#125; 使用 gcc 编译生成目标文件并运行 12gcc -o source source.c./source 会看到 1undefine __cplusplus 将后缀改成 .cpp ，重新编译运行 123mv source.c source.cppgcc -o source source.cpp./source 会看到 1define __cplusplus g++ 和 gcc 对采用了 extern &quot;C&quot;的 symbol 都会以 C 的方式来命名。 以下述文件为例 12345// me.h#ifndef _ME_H_#define _ME_H_extern "C" void CppPrintf(void);#endif 12345678// me.cpp#include &lt;iostream&gt;#include "me.h"using namespace std;void CppPrintf(void)&#123; cout &lt;&lt; "Hello" &lt;&lt; endl;&#125; 1234567// test.cpp#include "me.h"int main()&#123; CppPrintf(); return 0;&#125; 执行下述命令 12345gcc -S me.cpp# 或者# g++ -S me.cpp# 效果相同less me.s 可以看到 1call CppPrintf 将 me.h 中的 extern &quot;C&quot;删除后，执行下述命令 12345gcc -S me.cpp# 或者# g++ -S me.cpp# 效果相同less me.s 可以看到 1call _Z9CppPrintfv 参考 《后台开发：核心技术与应用实践》第 4 章 编译 ldconfig 命令]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>旧文补发</tag>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些 iOS 编译错误的原因及其解决方法]]></title>
    <url>%2F2017%2F08%2F26%2F%E4%B8%80%E4%BA%9B-iOS-%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近工作涉及到 iOS，使用过程中经常遇到不少错误，特此记录，以备查询。 所用环境为 Max OS 10.12.6 Xcode 8.3.3 iOS 10.3.3 0.出现错误后，在红色错误信息处，“右键 - Reveal in log - Detail Message” 会看到详细的出错信息，一般能从这里看到具体的问题是什么，然后采取相应的措施。 简单来说，就是两步“Google error message”、“Copy from StackOverFlow” 。 有时候一种现象，背后会有多种原因，于是就需要多试几种方法。总会解决的:). 由于本人对 iOS 完全是一知半解，如有不对之处，还望指出，不吝感激。 1. Applications are expected to have a root view controller at the end of application launchhttps://stackoverflow.com/questions/7520971/applications-are-expected-to-have-a-root-view-controller-at-the-end-of-applicati/32680220#32680220 iOS 从某个版本之后每个 window都要设置一个 RootViewController。否则在运行时便会挂掉。 检查你的 AppDelegate.m 文件（或者是 XXXXAppDelegate.m 文件）的 didFinishLaunchingWithOptions 函数。如果函数中是如下形式： [window addSubview:[someController view]];则将其改为 [self.window setRootViewController:someController];如果修改之后，仍报同样的错误。说明你程序中有不止一个 window ，而你并没有为每个 window 都设置了 RootViewController 。全部设置相应的 RootViewController 后即可解决。 需要注意的是 iOS 会默认根据 xib/storyboard 生成一个 window （本人对 iOS 并不是很熟，如果这里说法有误，欢迎指正）。所以有时候，你只有一个 window ，并且设置了 RootViewController 后还报错，则需要将类似如下代码的创建 window 的代码删除。 1self.window = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]] autorelease]; 2. 模拟器上正常运行，真机测试时报错 &quot;_WebPGetFeaturesInternal&quot;, referenced from: &quot;_png_get_io_ptr&quot;, referenced from: &quot;_TIFFGetField&quot;, referenced from: &quot;_jpeg_read_header&quot;, referenced from: &quot;_TIFFClientOpen&quot;, referenced from: &quot;_FT_Get_Glyph&quot;, referenced from: “右键 - Reveal in log - Detail Message” ，可看到 Undefined symbols for architecture arm64 这种情况通常是程序在 Build 的过程中没有将用到的所有 Library 链接进去。 通过“选中项目 - TARGETS - Build Phases - Link Binary With Libraries” ，并根据上面报错的名字，将相应的 Library 添加进去即可。 我这里是因为用了 cosos2d ，所以将 /PATH_TO_COSOS2D/cocos2d/external/XXX_MODULE/prebuilt/ios/libXXX[_arm64].a 包含进去即可。 将库添加后，如果还报错，则需在“项目 - Build Setting - Library Search Paths” 中添加“刚才添加的库”的目录。（在后面选择 recursive 可使编译器搜索指定目录及其子目录。) 3. unknow type name ‘namespace’等诸如 C++ 中的语法，编译时报错。通常报错的文件是 .h 文件，而包含该文件的是 .h 或 .m 文件。将 .m 后缀修改成 .mm 后缀，编译器便会将该文件当做 Objective-C++ 文件来编译。 或者选中文件后，在右侧的 “Identity and Type - Type” 中选择 “Objective-C++ File” 也可达到同样的效果。 4. library not found for -lcrt1.3.1.ohttp://blog.csdn.net/skylin19840101/article/details/56008803 crt1.3.1.o is a library that was included in older iOSes (and thus, their SDKs) but is no longer present in newer SDKs. However, when the project’s Deployment Target is set to an older ios (&lt;6.0, as @Sandy has found), Xcode still tries linking against it.在 iOS6 以及更高的版本中，crt1.3.1.o 已经没有了。 修改支持的最低 iOS 系统版本在 “项目 - TARGETS - General -&gt; Deployment Info -&gt; Deployment Target” 中，把 5.0(及以下的)改为 6.0(及以上的) 5. Use of undeclared identifier ‘glDeleteTextures’https://stackoverflow.com/questions/24024764/errors-showing-for-oes-opengl-statements-in-xcode-6-for-ios8添加如下代码 #import &lt;OpenGLES/ES2/glext.h&gt; 6. ‘release’ is unavailable: not available in automatic reference counting modehttps://stackoverflow.com/questions/22996437/release-is-unavailable-not-available-in-automatic-reference-counting-mode Xcode 设置中开启了 ARC ， 但是代码仍然进行了内存释放等操作。要么关闭 ARC ， 要么去掉代码中的释放内存相关的代码。 7. clang:error: -fembed-bitcode is not supported on versions of iOS prior to 6.0或者 12345/PATH_TO_COSOS2D/cocos2d/external/freetype2/prebuilt/ios/libfreetype.a(ftbase.o)'does not contain bitcode.You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE),obtain an updated library from the vendor,or disable bitcode for this target. for architecture armv7 这都是因为新的 iOS 不支持 bitcode 选项。将 “项目 - TARGETS - Build Setting - Enable Bitcode” ， 改为 no 即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>旧文补发</tag>
        <tag>XCode</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
