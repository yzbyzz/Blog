<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计划与执行]]></title>
    <url>%2F2019%2F08%2F25%2Fwx-plan-and-execute%2F</url>
    <content type="text"><![CDATA[睡觉前想了千条路，睡醒后还是走原路。间歇性打鸡血：觉得不能再这么颓废下去，结果还不用半天，就”真香”地玩起了游戏。想做的事情有很多，但都停留在了想的阶段，没有真正付出行动。总是有太多的理由和借口：每天上班回来很晚很累不想动，周末只想休息。诸如此类。 周末要好好休息，这个不错。但是看番追剧、玩游戏一整天，并不能算好好休息。看一天，首先是对眼睛不好，其次久坐对身体也不好。另外，一天都沉浸在电子世界，也会和现实有点脱落，导致精神有点恍惚，影响状态和思考。 就最近一段时间来看，坚持的还算可以的有记账、写日记。这两个是基本养成了习惯，大多数时候能在睡觉前花一点时间做完（除了有时候做 you 事xi 太沉迷）。这样看来，还是要将想做的事情变成习惯。同时要减少看番追剧的时间。特别是要留个心眼，明确自己当前在做什么。即便不能控制住，也要对自己的行为有意识。 不得不说，deadline 真的是第一生产力。目前还是勉强做到每周更新一次公众号。但也只是东拼西凑出来的一点“情绪”的抒发罢了。也许记录下自己一路的心境变化也是一件不错的事。谁知道呢。先写着吧。 （写公众号，让我想起了以前读书时，交作文前焦头烂额想主题、找素材的日子。不过现在一看字数，也就五百左右，也就是以前作文的一半字数左右。真的是写作能力越发下降了。） 周更第 3 周第 3 篇。]]></content>
      <categories>
        <category>微信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[延迟满足感]]></title>
    <url>%2F2019%2F08%2F18%2Fwx-delayed-gratification%2F</url>
    <content type="text"><![CDATA[难得的双休，完全自由的 48 小时，就这样过去了。没有看书，没有写代码，只有看番、看视频、玩游戏。并不是说不能玩游戏、看番，但总得有个度。不能做起这些事来，就停不下来，直到把番剧看完、肚子饿了才知道停下来。这样就不好了。 不好在哪里？如果就只是想要简单一点、轻松一点，这样子又好像没那么不堪？除了废寝忘食对眼睛和身体不好之外。但是实际上，现在这样简单轻松，以后是否还能如此简单轻松？都说程序员是个青春饭，现在还算年轻，自然还没有多大感受。可真等到不再年轻那一天才幡然醒悟，是否还来得及呢？ 另一方面，如果只是想要简单轻松，那么就该回老家工作才更加轻松吧。国内民企的程序员怎么都算不上轻松的工作。更何况还有一线城市的生活、教育成本。（当然一线城市也提供了更多的机会和医疗等公共资源，不然也不会有这么多人留下来了。） 既然已经选择了留在北上广深，那就该好好想清楚自己的目标才行。花多长的时间达到什么目标，为此有哪些时间点要做到哪些事情。一一计划下来，明确好每天该做什么，而不是无头苍蝇一样乱转。 有几点需要注意： 要让工作日和休息日的界限不那么割裂。否则休息日就完全颓废也很难受。 玩游戏、看番的时候要留一个“心眼”，要知道自己正在做什么，知道什么时候就该停下来。 找到正反馈。玩游戏能收到及时的反馈，很容易就沉迷。如果看书、写字也有类似的正反馈，那么也就更容易坚持下去了。 延迟满足感。找到了正反馈，还要能接受反馈的滞后性，让自己“多等一会”。 改变拿起手机后做的事：可以看看技术方面的文章，或者时事新闻。少看点风花雪月、吹牛、游戏攻略。 做事情的时候，不要因为搜索东西而忘了本来的事情。 每天的行动要固定下来：早上起来规划当天的任务，晚上回顾当天的执行情况。只要做到这一点，还是能一点点接近目标的。 这篇文章写的很仓促，主题不是很明确。更多是为了每周更新而临时拼凑出来的。以后还是要每天都写一点，写到合适的时候就发出来。才不至于如此。 （目前这样子日记性质的文章，有点迷。后面可能会改变公众号的主题和风格，在没有确定之前，还是先这样写着吧。） 周更第 2 周第 2 篇。]]></content>
      <categories>
        <category>微信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[实践番茄工作法：初窥门径]]></title>
    <url>%2F2019%2F08%2F11%2Fwx-door-of-pomodoro-technique%2F</url>
    <content type="text"><![CDATA[有时候忙了一天，最后却发现离目标没有靠近多少。主要在于目标不够明确，总想着这个可以做做，那个也可以看看，在执行的过程中逐渐迷失方向。一天过去，却还是原地踏步，没有完成最核心的事情。 更进一步，即便目标明确，如果目标过大，又没有将目标分解成几个较小的目标，也很容易因为目标过大，路径非常不确定，而导致走了很多弯路，付出许多无用功。 想到番茄工作法这个 25/5 的循环，在休息时就可以回顾刚才的工作，确认目标、修正方向。看似频繁的休息，实际上因为多次的确认、反思，反而让自己更清晰，更加不容易走弯路，最后更能节省时间。我觉得这一点是番茄工作法的核心。 我以前是基本不做计划的，甚至还自诩为自己的特点。实际上，很多事情都不是一朝一夕就能完成的。这样的事情如果没有计划是很难完成的，更别说高效了。之前都是只用了番茄工作法 25/5 循环的这个“形”，却没有真正掌握其“神”。以致于每次到点休息，还“舍不得停下来”，总想着“把眼前的工作继续到一段落”再说。这两天开始强迫自己实践：工作时就全神贯注、一心一意；到点休息就停下来，好好评估回顾刚才的工作与整体的目标和进度，并考虑下一个番茄钟的工作。一天下来，反而完成了不少工作。主要在于时刻明确自己的主要目标，从整体上把握，不会陷在细节中迷失方向。同时也发现了一个新的问题就是，对任务所需时间的预估不够准确，这个就需要继续实践，以便对自己的专业能力和执行力有更清晰的认识。 总而言之，还会继续实践番茄工作法。后面有新的想法也会继续更新。 以周一作为开始，从本周一（08.05）开始，每周都至少更新一篇文章。看看能坚持多久。如果一周没更新，则重新计数。 周更第 1 周第 1 篇。]]></content>
      <categories>
        <category>微信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日更七天的想法]]></title>
    <url>%2F2019%2F08%2F01%2Fwx-thoughts-after-post-7-days%2F</url>
    <content type="text"><![CDATA[实际上 28 号开始写这篇文章。主要是在更新过程中，一些想法油然而生。 自己的疏忽 公众平台的文章发送出去后，能做的修改就很少了。虽然以前也有所耳闻，等自己实际体验到还是感觉很不一样。刚开始发文章，本想着标记原创，写完后还检查了几遍：有无错别字、是否通顺。最后却漏了看原创声明。又因为打算日更，所以也不好删除重发，就这么留着吧。其实也没什么，就是有点逼死强迫症。 微信的自然量 微信公众平台对新人挺不友好。写完文章后，不发到群里不点赞不发票圈，几乎没有用户会看到。阅读量没眼看，评论点赞就更不必说了。可能还是需要先在其他地方有一点基础，再写公众号才比较好。当然像我目前这样完全不主动传播的也比较少见。 每日输出的要求 每天日更，让我回忆起了读书时被作文 deadline 支配的恐惧。特别是后几天，写文章的时候，各种拖延，几乎压着 deadline 完成。还是要改改这拖延的习惯。另外一方面，因为每天都写，又没有反馈，所以后面有时候抱着一种完成任务、凑数的心态，不够认真。 无从下笔 心中笔墨不多，有时候不知道写什么好。像这几天的文章，最后大多写成观后感、读后感，因为这样很多文字不用自己写。这几日也几乎没有看书，说到底还是以前读的书没有真正掌握，只是看过就算。虽然看书本身也算有趣，但书看完，还是要有所长进才行。写文章就是一个衡量读书质量的标准。 后记 这次的七天日更算是顺利完成。为了保证有时间输入，以及提高输出的质量，以后改成周更。每周固定周四和周日这两天更新。目前暂定晚上九点更新。这次就先坚持到中秋节，看看执行情况如何。]]></content>
      <categories>
        <category>微信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从工具选择说起]]></title>
    <url>%2F2019%2F07%2F31%2Fwx-talk-from-tool%2F</url>
    <content type="text"><![CDATA[作为一个技术人，对工具的态度也经历了几个阶段。拿文本编辑器为例。 不知有工具 最早接触到的文本编辑器，自然就是 Windows 自带的记事本。编辑功能很弱，只能说是可以用的程度。当然那时候对文本编辑的需求也不多，也就不深究。 迷信自 fu 由 za 度高的工具 上大学后，接触到 Vim 这个编辑器之神。一开始真的是各种不适应，连移动光标、编辑、保存、退出这些基本功能都要学习才能知道怎么操作。慢慢用多之后，逐渐熟练起来，也体会到这种手不离键盘带来的高效。对 Vim 的喜爱也到了偏执的地步，以至于研究和安装各种插件：树形目录、关键字标识/搜索、自动补全等等。后来写程序的时候，甚至嫌弃 IDE 过慢，而使用 Vim 来写代码。（实际上慢的原因是代码在局域网上，本地通过 Samba 连接，IDE 要编辑局域网的东西自然不快。而 Vim 是 SSH 登陆到局域网机器上使用的。）看似编辑的速度快了不少，然而缺少了 IDE 的提示，代码写完一编译，各种报错——根据提示修改错误，继续编译，重复这个循环若干次方能编译通过。可惜当时身在其中，竟不知跳出这个怪圈来。 拥抱 IDE，拥抱简单 后来改变开发流程，将代码放到本地，也用起 IDE。各种智能提示，让不少错误在写代码的阶段就暴露出来，写完代码就能编译成功的感觉真的很不错。当然逻辑错误还是要自己去 debug 的。更方便的是，IDE 可以安装 Vim 插件，这比使用 Vim 然后自己手动去折腾要方便太多。 后记 除了文本编辑器，其他工具也是如此。我在云笔记、GTD 软件上都经历过一段时间的“探索”：总是觉得各种不如意，想要找一个“完美”符合自己各方面期望的工具出来。结果，在寻找的过程，反而渐行渐远，忘记了使用工具的初衷。还是那句话，工具本身不是目的，只是一种手段。 不要舍本逐末，许多事情都是如此。]]></content>
      <categories>
        <category>微信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[番茄工作法]]></title>
    <url>%2F2019%2F07%2F30%2Fwx-pomodoro-technique%2F</url>
    <content type="text"><![CDATA[大多数人对番茄工作法的理解停留在「工作/学习 25 分钟，休息 5 分钟」这样的循环。这只是一个很小的方面，番茄工作法更多的是一种思维方式。空有其形无法发挥出番茄工作法真正的威力。 番茄工作法的完整流程包括：计划、执行、评估、应用四个步骤。三十分钟的循环只是其中的一步。下面简单介绍各个步骤需要做什么，以及有哪些注意点。 计划 就像 GTD 那样，需要一个待办任务清单来收集所有的任务。每天早上，根据当天的安排（工作、学习、休息、出游）来确定有多少时间可以用来完成任务。这里需要将时间换算成番茄钟来计算，半小时长度的番茄钟就很方便计算。人一天中能集中精力、高效工作/学习的时间通常不会超过五六个小时，所以一天的任务所需的番茄钟一般不应超过十个。可能有人会觉得一天这么长，就只计划这么点时间，是不是有点浪费。但是你要明白，这是全神贯注的十个番茄钟，是十分难得，也是非常高效的。如果你仔细回忆就会发现，对于大多数人来说，每天看上去从早忙到晚，但实际上有不少时间都是在做与任务无关的——比如看聊天软件、刷信息流、剁手之类。 做计划的目的不在于多，而在于有效——确实能在计划的时间节点上高质量地完成相应的任务。 执行 执行过程就是循环执行半小时的番茄钟。用什么软件并不重要，甚至用手机闹钟会更方便——当今都是手机不离身，任何时候都可以收到番茄钟的提醒。这里主要的是养成几个习惯和反射： 一旦开始番茄钟，就集中精力，不去处理与当前任务无关的事情。关键不在于当前活动能否在当前番茄钟内完成，关键是在这一刻你尽了全力。 如果中途想起其他任务，也只是先记录下来，仍然继续当前任务。 假如任务提前完成，番茄钟还未结束，也不要去处理新的任务。可以对当前任务做个回顾、整理，这样可以让自己更有印象、也能提升相应的技能。 一旦番茄钟响起，无论当前任务是否完成，都应该停下来好好休息。有时候停下来甚至比开始做更难。特别是写代码的时候，突然被打断，是一件相当恼火的事情。这时使用软件的优势就会体现出来——软件可以在时间点之前先提醒一次，给你一点准备的时间。 休息后，若任务的确需要今天完成，那么就重新开始一个番茄钟，继续这个任务。否则的话，将任务继续加入待办任务清单，执行新的任务。 评估与应用 每天晚上，回顾当天的计划和执行情况：当日的任务是否都完成，总共花费多少番茄钟，有哪些任务花费的番茄钟比预料的多或者少，预料错误的原因是什么。为逐步提升计划的有效性，评估是必不可少的。通过每日的评估，让自己更加明白问题所在，从而下次评估时间更准确，计划和执行时更加心中有底，不着急也不放纵。因为你知道计划已经做好，事情都会按部就班地一一完成。 实践体会 几周体验下来，感觉每一步都做的不够好。 早上的计划做的不够明确，不能预估好需要的番茄钟。 执行过程中，到点时不能马上停下休息。 晚上的评估和应用做的不够。 这样说来，我对番茄钟的应用还很初级，还需要很长的探索。也的确如此。 在实践的过程，出现一种想法：计划每日任务的时候，采用类似读书时候的课程表那种形式，可能从视觉上更能看出每个时间点要做什么、每个任务要花费多少番茄钟。目前好像还没有看到比较符合这个想法的软件。我这造轮子的想法又蠢蠢欲动了。不过还是先把自己的践行水平提升一番再说。]]></content>
      <categories>
        <category>微信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从造轮子说起]]></title>
    <url>%2F2019%2F07%2F29%2Fwx-build-wheel%2F</url>
    <content type="text"><![CDATA[在 IT 领域，造轮子常用来比喻重复制作已有的工具。 什么时候，会有造轮子的需求？按我的理解，有如下原因。 （1）觉得已有的轮子不够好、不方便、不符合自己的理念，所以想要制作更好的工具，造福自己和他人，还能提升自己的影响力。 （2）知道已经有现成的工具，也知道自己很难超越，造轮子只是锻炼自己和加深理解。 两种情况虽然目的不同，但在造轮子的过程都会让自己的能力得到锻炼，对轮子相关的概念、理念有更深的理解。所以从提升自我的角度来看，造轮子是值得肯定的，也是应该鼓励的。 另一方面，如果是在正式项目中使用，在理解相关概念和用法的基础上，还是更偏向于使用已有的、稳定成熟的工具。这样可以节约大量人力、物力，有利于项目的平稳推进。毕竟有别人的经验不用，却自己去踩一遍坑，从商业上是很不理智的。大多数时候，这和企业要创造利益、价值这一主要目的是不符的。 文章标题虽然叫《从造轮子说起》，我自己的想法却不是从此而起。另有所思，后来才想到这就是造轮子的问题。缘起如下。 前阵子看《番茄工作法》（后面可能会写一篇读后感和实践的思考），最近在实践，没有找到称心的工具，就想着不如自己动手做一个，还煞有其事地列出不少功能点。几周过去，代码一行都没有写。不由得感叹自己拖延症之严重。又想起这本质就是个造轮子的工作。更何况市面上真的没有符合的工具吗？自己那些需求是否真的有必要，真的不能满足吗？这样转念一想，觉得还是要放下看见什么都想造轮子的“想法”，多点更专注、集中的造轮子行动。首先要提升技术深度，在某个点上有深刻的理解才行。 又想起那句话，我们几乎能完成任何我们想做的事情，但我们不能同时完成所有的事情。找到自己的方向并且坚持下去就已经难能可贵了。]]></content>
      <categories>
        <category>微信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[怦然心动的人生整理魔法]]></title>
    <url>%2F2019%2F07%2F28%2Fwx-clear-up%2F</url>
    <content type="text"><![CDATA[看了几章《断舍离》，发现在翻来覆去地讲断舍离的好处，读起来有点空泛。我知道断舍离好，也的确该果断丢弃一些用不到的东西。但我现在想知道的是怎么做到断舍离。然后又看起《怦然心动的人生整理魔法》这本书，发现这才是我目前需要的。今天花了一两个小时将书读完。谨以此文记录书中一些印象比较深的观点。 一、整理是对过去的整理。身边的每样东西总是有各种各样的原因才会来到你身边成为你的东西。在整理的过程，不止是对这些物品做出丢弃或保留的选择，也是对自己过去的选择和人生轨迹的一个梳理。 二、整理本身不过是一连串简单的工作——把东西丢弃或者收好，任何人都可以做到。难的地方在于整理后，如何保持效果，而不是很容易就打回原形——再次变乱，需要再次整理。关键在于只保留需要的物品，同时养成持续保持整洁的习惯。 三、做好整理其实只有两件事：丢弃和收纳。 （1）首先将所有不需要的东西都丢弃。 （2）将决定留下的东西收纳、保管好。 通过对目前已有的物品做一次完全的整理，达到整洁的状态。 接下来就是如何保持整洁。 四、保持整洁的状态同样需要做到丢弃和收纳。 首先考虑会破坏整洁的情况，无非是使用物品后没有放回原处，或者是获得新的物品。接下来说说怎么应对： （1）无论是使用物品还是获得新物品，都应该将他们收纳、放到合适的位置。如果发现物品收纳的位置不方便使用，那么：要么修改收纳的位置，要么修改使用的习惯。总而言之，给每个物品确定好位置，并且在使用后一定放到那个位置。 （2）如果获得新物品，而且已经有相似的旧物品，那么就要考虑是否还需要旧物品。如果旧物品已经完成它的使命，那么就心怀感激地果断丢弃，而不是留着又不使用，那才是对物品的浪费。 五、整理物品时应该按种类，而不是按场所或者其他因素。 先将所有的同种物品都拿出来，才能让自己意识到这种物品的数量。这时候更容易发现很多物品实际上用不到，早就应该丢弃。同时，也方便自己从中做对比，将已经不喜欢的、用不到的、不能用的都果断丢弃，只保留那些能让自己心动的、想要使用的、也确实有机会使用的。 如果按照场所来整理，可能换一个房间整理时，又会翻出类似的物品，但因为物品没有集中在一起，对总体数量不能有一个很好的掌控，更容易把物品保留下来。 六、整理物品也要有顺序。 整理时要先从难度低的开始。如果一开始就从纪念品上手，很容易就陷入对往事的回忆之中。另一方面，从简单的物品开始，也更容易提升我们的判断力——丢弃还是保留一件物品的判断力。 推荐的整理顺序是这样的：首先是衣服，其次是书籍、文件、小件物品，最后才是纪念品。 七、整理物品时应该尽量让物品立起来。 就像书籍放在书架上，可以清楚地看到每本书的简介，也方便收放一样。衣服最好也是叠成一个长方形，可以立起来。至于商城里面那样则不太合适：将衣服简单折叠，像一张大饼一样铺着，很多衣服就这样堆叠得很高。衣服堆叠后，下面的衣服就很不方便拿——每次都要先将上面的衣服拿走，否则将下面的衣服直接抽出来的话很容易就把其他衣服打乱。另外，下面的衣服不容易发现，很容易就被忽略，长时间被积压后容易出现痕迹。因此，让衣服像书籍那样立起来是很有必要的。 另一方面，如果衣服不折叠，全都用衣架挂在衣柜里的话，就会很占用空间。因此除了一些大衣、衬衫之类的，尽可能将衣服折叠并立起来，才能在空间和方便上取得更好的平衡。 八、家庭的每个成员都应该有属于自己的独立空间。 这样一份独属于自己的空间，会让人更有动力去收拾和保持整洁。同时也让每个人可以存放那些具有独特回忆或特别意义的物品。 九、整理只是一种手段不是目的。 正如作者在书中所说「整理作业应该尽快结束，因为整理并不是人生的目的。对『具有真正心动感』的工作倾注更多的时间和热情吧。」整理是为了让我们生活的空间更舒适，以便我们更好地投入到心动的事情之中。对大部分人而言，整理并不是最心动的事情。 十、无处不需要整理。 生活物品需要整理，我们学习掌握的知识同样需要整理。整理的过程，既是对旧知识的回顾，也是对新知识的融会贯通，这样才能建立起自己的知识图谱，更好地加深理解，更利于日后的输出。 生活物品需要整理，我们内心的想法、欲望同样需要整理。我们几乎可以做到任何我们想要的事情，但我们不能同时做成这些事情。通过对自己的整理，让自己的目标更明确，让每一天的行动更高效。]]></content>
      <categories>
        <category>微信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[大秦帝国]]></title>
    <url>%2F2019%2F07%2F27%2Fwx-qin-empire%2F</url>
    <content type="text"><![CDATA[最近看呂世浩的公开课《秦始皇》，很喜欢老师讲课的方式，一口气看完整个课程。其中给我印象比较深的有以下几点： 一、学历史不在于记住时间地点，而在于从中思考前人所处的环境以及相应的做法。设身处地，如果是自己面对同样的情况，又会做出什么行为？不同的行为会导致什么样的结果？通过这样的思考，加深自己对前人的理解。更重要的是：当自己以后碰到类似的情况时，因为思考过，所以更有可能做出适当的选择。毕竟，历史总是不断的重复。 二、理想和空想有什么不同。两者都有宏伟的目标，不同之处在于：理想是有计划的，知道每一步要做什么，清楚当前的下一步是什么，不是像空头苍蝇一样乱转；而空想则空有目标，却没有计划、没有行动。 三、成功的定义是什么。每个人的价值观不同，对成功的定义也不尽相同。一个比较普遍的定义是：成功就是过上自己想要的生活。每个人想要的生活不同，有人想要翻云覆雨，有人希望云轻云淡。这都是个人选择，无可厚非。重要的是知道自己想要什么，并且知道应该做什么，也真的去做。 四、如何才能成功。首先是不自欺。要清楚自己的处境和能力，不欺骗自己，根据现实制定目标、做好计划。其次是百折不挠。追求成功的过程肯定不是一帆风顺的。有太多的人想要成功，但是最后能成功的却很少。一个重要的原因就是坚持很难，很少有人能做到越挫越勇。最后就是把握机会。成功除了自身的努力，还需要好的时机。只有做好准备，才能即时抓住机会。 五、秦国为什么最终能统一天下。因为秦国的军队战斗力强。 为什么战斗力强？因为军功爵制度。打仗立功就能升官加爵。人民参战的积极性高，作战勇敢。狭路相逢勇者胜。 六、既然秦国因为军功爵而强兵强国，六国也都知道，那为什么六国不学？因为这样要重新分配利益，把土地、资源分配给获得军功的人，会伤害既得利益阶级。相比国家和人民，既得利益阶级更在乎自己的利益。 七、帮助别人，别人不一定会感恩。秦王嬴政和燕子丹，小时候都在赵国做人质，同病相怜，交情不浅。但是赵国和燕国的关系，明显比和秦国的好。所以嬴政吃了不少苦，也多亏燕子丹照顾了不少。 后来嬴政回国成了秦王。再后来燕子丹到秦国做人质。燕子丹本来以为凭着以前的交情，在秦国的日子肯定不会太难过。没想到的是在秦国过的很不愉快，处处受到打压。 究其根本，就是嬴政成为秦王后，成为天下第一强国的第一人，权势喧天。每当看到燕子丹，就不由得想起以前那段寄人篱下、身不由己的苦难日子，也就难免会觉得燕子丹碍眼——燕子丹的存在无时无刻不在提醒嬴政回忆起那段日子。 另一方面，燕子丹正因为到秦国后的落差过大，才导致对嬴政的怨恨非比寻常，以至于派出杀手。 八、做一件事、做出选择就要付出相应的代价。秦始皇死的时候，李斯在赵高的蛊惑下，修改遗命——赐死扶苏、蒙恬，立胡亥，暂时保住自己的地位。相应地也选择赵高这样的人作为队友。赵高也是想要权势的人，而拦在前面的恰恰就是李斯，也就不难理解李斯最后的下场。 九、大多数时候，长辈的话还是要听听的，特别是父母的想法。大多数人的父母都是不会害自己孩子，会把自己人生中觉得最重要的事说给子女听。虽然有时候，有些可能会不符合时代，但听一听、从其他角度思考总是不坏的。然而我们大多数时候都会把这些话当耳边风，等到碰南墙再自己得到相似的感悟。 十、秦国的军队如此强大，能够灭亡六国，为什么还会二世而亡？统一六国后，秦始皇自诩为古今第一人，视天下苍生如蝼蚁，将天下所有的人力、物力都拿来满足自己的欲望：建阿房宫、修驰道、修长城、北御匈奴、南征百越。人民苦不堪言，不堪重负，为了生存只能起义。 秦始皇后来这样强烈的欲望，也可能与灭六国前迫切地想要统一天下而压抑自己的情感有关。]]></content>
      <categories>
        <category>微信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[现在永远不会太晚]]></title>
    <url>%2F2019%2F07%2F26%2Fwx-now-is-never-too-late%2F</url>
    <content type="text"><![CDATA[申请公众号 3 年后，终于动手写下第一篇文章。 为什么要写 本身有在写日记，只不过日记是写给自己看的。写公众号，主要出于如下的考虑： 一、记录生活、分享感悟、交流想法，找到志同道合之人。二、锻炼写作能力，提升影响力。三、写出心中所想，在写的过程中，也逐渐理清自己真正的想法，更好地理解自己。 写什么 大体而言，主要包括如下：对生活、时事、科技、理财等方面的个人见解；程序设计、开发、运维等技术方面的想法、思考；读后感、观后感等等。 怎么写 目前是希望做到日更 300 字以上的文章。为了不打脸，就先尝试日更一周看看效果。从今天（7 月 26 日）到 8 月 1 日是一周的时间，先看看自己能做到什么程度。 千里之行，始于足下。今天就在这里踏出第一步。]]></content>
      <categories>
        <category>微信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂模式(为什么很多人觉得工厂模式没有用)]]></title>
    <url>%2F2019%2F06%2F30%2Fdesign-patterns-factory%2F</url>
    <content type="text"><![CDATA[前言随着编程技术的不断发展，面向对象语言和面向对象程序设计逐渐成为主流。这就不可避免地涉及到了对象的创建。创建一个对象，并使用已经定义好的方法，看起来也很清晰和简单。有的时候，在不同的情况下需要不同子类的对象，如何降低耦合度、方便地进行切换，而不需要将所有实例化该对象的地方都进行修改，则涉及到了模式。 下面将依次介绍简单工厂模式、工厂方法模式、抽象工厂模式，说明他们是如何实现创建对象这一功能的。(后文将三者统称为工厂模式。) 简单工厂模式一个很简单的做法，既然你说可能要使用不同的对象，那我将所有创建对象的操作都集中起来，只在一个地方进行对象的创建，其他地方都通过这里来创建对象。以后即便要修改，也只需要改一处地方不就可以了。 以生产鼠标为例，我们需要有线鼠标和无线鼠标。则大致的代码如下： 123456789101112131415161718192021abstract class Mouse &#123;&#125;class WiredMouse : Mouse &#123;&#125;class WirelessMouse : Mouse &#123;&#125;class SimpleFactory_1 &#123; public Mouse createMouse(String type) &#123; if ("wired".equals(type)) &#123; return new WiredMouse(); &#125; else if ("wireless".equals(type)) &#123; return new WirelessMouse(); &#125; else &#123; // unknown type ! return null; &#125; &#125;&#125; 简单工厂模式十分简单直观，代码量也很少。这份代码的一个改进之处是将 createMouse 的参数从 String 类型改成枚举类型，以免使用时拼写错误，也能更好地对参数进行限制。 简单工厂模式的缺点是，如果我们需要增加新的鼠标，那么我们就必须修改 createMouse 方法，增加 if/else 语句。这样就破坏了”对修改封闭”的原则。 简单工厂模式可以定义成静态方法，也可以定义成实例方法。他们的特点如下： 静态方法 无需创建对象就能使用 不能使用继承来改变创建方法的行为 实例方法 需要创建对象才能使用 可以使用继承来改变创建方法的行为 更进一步，假设有 A、B 两家公司都生产有线和无线鼠标，他们的鼠标定义如下： 12345678910111213// A 的鼠标class AWiredMouse : WiredMouse &#123;&#125;class AWirelessMouse : WirelessMouse &#123;&#125;// B 的鼠标class BWiredMouse : WiredMouse &#123;&#125;class BWirelessMouse : WirelessMouse &#123;&#125; 对应的简单工厂模式代码如下： 1234567891011121314151617181920212223242526class SimpleFactory_2 &#123; public Mouse createMouse(String factory, String type) &#123; if ("A".equeals(factory)) &#123; if ("wired".equals(type)) &#123; return new AWiredMouse(); &#125; else if ("wireless".equals(type)) &#123; return new AWirelessMouse(); &#125; else &#123; // unknown type ! return null; &#125; &#125; else if ("B".equals(factory)) &#123; if ("wired".equals(type)) &#123; return new BWiredMouse(); &#125; else if ("wireless".equals(type)) &#123; return new BWirelessMouse(); &#125; else &#123; // unknown type ! return null; &#125; &#125; else &#123; // unknown factory ! return null; &#125; &#125;&#125; 可以看到代码开始复杂起来了，如果还有更多公司 C、D 也在生产鼠标，或者有更多的鼠标类型，那么这个工厂类将会更将复杂。 工厂方法模式下面我们就来看看工厂方法模式是如何处理这种问题。 1234567891011121314151617181920212223242526272829abstract class Factory &#123; public Mouse CreateMouse(String type);&#125;class AFactory_2 : Factory &#123; public Mouse CreateMouse(String type) &#123; if ("wired".equals(type)) &#123; return new AWiredMouse(); &#125; else if ("wireless".equals(type)) &#123; return new AWirelessMouse(); &#125; else &#123; // unknown type ! return null; &#125; &#125;&#125;class BFactory_2 : Factory &#123; public Mouse CreateMouse(String type) &#123; if ("wired".equals(type)) &#123; return new BWiredMouse(); &#125; else if ("wireless".equals(type)) &#123; return new BWirelessMouse(); &#125; else &#123; // unknown type ! return null; &#125; &#125;&#125; 可以看到，工厂方法模式中，定义了多个工厂类分别对应各自的公司，每个类只负责创建自己的鼠标，而不用管其他公司的。 如果还有更多的公司，则定义新的工厂类即可，不需要修改已有的代码。 如果需要生产更多类型的鼠标，则需要对工厂都做修改，增加相应的 if/else 语句来处理。这一点与简单工厂模式类似。 工厂方法模式，体现了”对扩展开发，对修改封闭”。 这里为了说明使用工厂方法模式相比简单工厂模式的优点，特意给鼠标增加了公司（A、B）和类型(有线、无线)这两个纬度，以便说明工厂方法模式对代码职责进行划分。 实际上，对应简单工厂 SimpleFactory_1 也可以改成工厂方法模式，代码如下： 123456789101112131415abstract class Factory &#123; public Mouse CreateMouse();&#125;class WiredFactory_1 : Factory &#123; public Mouse CreateMouse() &#123; return new AWiredMouse(); &#125;&#125;class WirelessFactory_1 : Factory &#123; public Mouse CreateMouse() &#123; return new AWirelessMouse(); &#125;&#125; 抽象工厂模式这些公司除了生产鼠标外，还会生产键盘等产品。键盘的定义如下： 12345678910111213141516171819202122abstract class Keyboard &#123;&#125;class WiredKeyboard : Keyboard &#123;&#125;class WirelessKeyboard : Keyboard &#123;&#125;// Aclass AWiredKeyboard : WiredKeyboard &#123;&#125;class AWirelessKeyboard : WirelessKeyboard &#123;&#125;// Bclass BWiredKeyboard : WiredKeyboard &#123;&#125;class BWirelessKeyboard : WirelessKeyboard &#123;&#125; 对应的抽象工厂模式如下： 123456789101112131415161718192021222324252627282930313233343536373839abstract class Factory &#123; public Mouse createMouse(String type); public Keyboard createKeyboard(String type);&#125;class AFactory_2 : Factory &#123; public Mouse createMouse(String type) &#123; // 与之前一致 &#125; public Keyboard createKeyboard(String type) &#123; if ("wired".equals(type)) &#123; return new AWiredKeyboard(); &#125; else if ("wireless".equals(type)) &#123; return new AWirelessKeyboard(); &#125; else &#123; // unknown type ! return null; &#125; &#125;&#125;class BFactory_2 : Factory &#123; public Mouse createMouse(String type) &#123; // 与之前一致 &#125; public Keyboard createKeyboard(String type) &#123; if ("wired".equals(type)) &#123; return new BWiredKeyboard(); &#125; else if ("wireless".equals(type)) &#123; return new BWirelessKeyboard(); &#125; else &#123; // unknown type ! return null; &#125; &#125;&#125; 可以看到：现在一个工厂会负责生产鼠标、键盘等多种产品，并且每个工厂只负责自己的部分。 如果还有新的公司也可以生成鼠标、键盘这些产品，则只需要添加新的工厂类即可，无需修改已有的类。 如果还要生产更多的产品比如显示器等，则需要修改所有的工厂类。 这里的例子，工厂方法也可以拆成抽象工厂来表示。。 总结简单工厂模式的重点在于将创建产品的代码统一在一处，方便管理。 工厂方法模式、抽象工厂模式除了将创建产品的代码统一在一处，还提供了一种便捷地更换产品系列的能力——当我需要 A 公司的产品，那么就使用 AAFactory；当我需要 B 公司的产品，那么就使用 BFactory；只需要修改使用的工厂即可实现将所有的产品都改成对应的产品，大大降低了耦合度和修改的成本。 很多时候，我们只需要用到简单工厂模式就足够了。但这并不是工厂方法模式、抽象工厂模式没有用，而是很多时候没有这种需求——我们只需要一种类型的产品就足够了，并不需要同时支持多种产品；在这种情况下，使用简单工厂模式的确会更加简单。 然而，一旦我们同时需要不同类型的产品，那么简单工厂模式就很容易使得方法体快速膨胀，使用工厂方法模式和抽象工厂模式可以更好地对代码和职责进行划分。 工厂方法模式只生产一种产品，而抽象工厂模式则是生产一系列产品(，通常这些产品之间有一定联系的)。抽象工厂模式生产其中的每个产品时，通常使用工厂方法模式。 参考 《Head First 设计模式》 《设计模式 可复用面向对象软件的基础》]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minecraft 从入门到入坑]]></title>
    <url>%2F2019%2F05%2F04%2Fminecraft-guide%2F</url>
    <content type="text"><![CDATA[Minecraft 是一个高度开放的沙盒游戏。这里简单介绍一下 Minecraft。 简单展示首先放几个视频展示 Minecraft 能做什么。 建筑向： 【Minecraft】EpicWork建筑团队出品——武陵尘梦• - 【OFL工作室】诸神的黎明Minecraft出生点建筑 红石科技向：- 大神在我的世界里建造一台能够运行的电脑,在我的世界里就没有什么不可能！ 生存向：- 【敖厂长】在MINECRAFT中成家立业 - 【Minecraft】来看一看一个生存六万五千分钟的存档里 - Pi,mc,极限生存part1~2 游戏版本 Java 版 支持 Windows、macOS、Linux 系统的电脑。只要运行 JRE 即可。 基岩版 支持 Windows、iOS、Android 等。 主机版 其中 iOS、Android 端，分成了国际的基岩版，和国内的网易版。 Java 版的玩家人数最多，且有丰富第三方 mod、材质包等。我主要玩的是 Java 版，只玩过一点的 iOS 基岩版。后文都以 Java 版为例。 启动游戏 正版玩家。在官网购买后即可使用正版启动器开始游戏。 盗版玩家。下载 HMCL 后使用 HMCL 开始游戏。请支持正版。 功能加强个人建议资源到国外的 CurseForge 下载，尽量避免在第三方下载。国内很多站点是搬运、翻译 CurseForge 的资源。 材质包Minecraft 本身的画风是像素风格，很粗糙。但是可以通过材质包和光影(显卡杀手)来改善画面。具体操作是：从资源站下载材质包后丢到相应的文件夹，即可在游戏中选择切换。 ModMinecraft 本身有很强的开放性，还可以通过第三方 mod 来提高游戏丰富性，以及改善操作体验等。具体操作与使用材质包类似：从资源站下载并丢到相应的文件夹。需要注意的是，使用 mod 之前需要先安装 Forge 或者 LiteLoader 才能使用第三方 mod。然后就是 mod 需要注意与 Minecraft 游戏本体版本匹配，以及有些 mod 依赖其他 mod，最后就是有些 mod 之间可能有冲突。 个人推荐必备的 mod 有：JourneyMap 地图插件、Just Enough Items 物品合成查询、Inventory Tweaks 背包整理。然后就是程序员必备的 ComputerCraft 和 OpenComputers ——可以使用 Lua 语言编写代码控制”机器人”来执行操作，释放双手。 如果你有自己的需求，你甚至可以使用 Java 来编写自己的 mod！ 多人游戏局域网有一个人选择对局域网开发，其他人通过多人游戏，输入局域网 IP 即可加入。 外网第三方内网映射使用蛤蟆吃、花生壳等映射内网后，使用局域网的方式联机。 使用服务器 需要一台有外网 IP 的服务器(可在阿里云、腾讯云等购买)。 在服务器上运行 Minecraft 服务端 jar 包即可。(可使用 scrren 命令以便后台运行服务端，并在需要时进行控制。) 本地运行相同版本的客户端，通过多人游戏，输入 IP 和端口号即可。 自己用软件做内网映射如果不想或者不方便使用蛤蟆吃等第三方软件，自己有服务器，但是服务器配置不高或者不想使用太多的服务器资源，可以在服务器上搭建内网映射服务，只做转发功能。此时对服务器的硬件要求不高，只要网络流畅即可。 PS. 内网映射可以使用 frp 来搭建。 使用路由器做内网映射 [联机] 家用电脑映射开服完整详细图文教程 服务器版本选择各个版本的比较： https://minecraft-zh.gamepedia.com/index.php?title=Server.properties&amp;variant=zh [生存] [服务端整合包发布] [1.5.2-1.10.2]从这里,你可以找到全世界里关于服务端最全的一切！ [生存] [服务端整合包发布] [1.x-1.12.2][多种]服务端核心合集&amp;搭建好的服务端★你想要的 都在这【内置教程】 mcbbs 联机教程 [娱乐] [服务端整合包发布] [1.x-1.12.x][全部]服务端合集|SCT|小喵 — 你想要的我们都有|插件汉化教程|内有彩蛋 [心得] [1.12]sponge海绵端创建与心得 Minecraft Forge 安装 SpongeForge 主要对比如下： 各服务端都有些什么区别？minecraft_server（即官服）为官方的服务端，每有一个新版MC出来，官服都会跟着出不能加插件，不能加MOD，仅能使用原版的指令可自定义功能少 官服+Forge（即MOD官服）在官服的基础上加入了Forge，稳定性较好仍无法加插件，可以通过MOD添加非原版的指令可自定义功能少 Cauldron（即MCPC+，KCauldron，MOD服）MCPC+为先前的名字，KCauldron为最后几个1.7.10版的名字优点：既能加MOD又能加bukkit插件缺点：①bukkit插件并非完全兼容，仍有一些无法正常运行②由于MOD和插件并在一起，经常会出现不可避免的BUG，例如核弹炸领地③较吃配置，稳定性良可自定义功能较多 ThermosCauldron的优化版优点：既能加MOD又能加bukkit插件相较于Cauldron更安全，稳定性更好对插件的兼容性比Cauldron更好缺点：①bukkit插件并非完全兼容，偶有一些无法正常运行②由于MOD和插件并在一起，经常会出现不可避免的BUG，例如核弹炸领地可自定义功能较多 Craftbukkit（即水桶服）Spigot的前身，可以加入bukkit插件优点：稳定性较Cauldron相比较好，能够兼容绝大部分的bukkit插件缺点：部分方面优化较差，一些专为spigot制作的插件无法运行可自定义功能较多 Spigot（即水龙头）Craftbukkit的优化版，可加入bukkit插件优点：稳定性较Craftbukkit相比更好，在Craftbukkit一些卡服的问题上做出了优化服务端自带反作弊缺点：暂未发现可自定义功能多 PaperSpigot【目前使用数最多】Spigot的优化版，可加入bukkit插件优点：稳定性和Spigot一样，但是Spigot上一些仍可造成卡服的问题在这基本没有了内存占用量更少，并且多出了一些涉及到服务器性能的设置1.9之前内置反作弊缺点：极少数插件不支持可自定义功能非常多 TacoSpigotSpigot的优化版，可加入bukkit插件优点：在卡服优化方面比Paper更强内存占用更少缺点：部分插件不支持可自定义功能非常多 TorchSpigot【国人制作】TacoSpigot的优化版，可加入bukkit插件优点：在各方面性能相较于Taco更加好，稳定性十分强，可自定义方面比Taco更多支持多核心运算，并内置反作弊缺点：少量插件无法使用可能会出现一些奇怪的BUG以及报错可自定义功能非常多 SpongeForge（即海绵端）有人称为Cauldron的后续版本，可加入Sponge插件优点：支持Sponge插件，同时可以加入MODMOD与插件之间的兼容性相较于Cauldron加强了不少Sponge插件可在客户端中安装优化极为强，只要不报错几乎没Bukkit的各种卡服缺陷未来可实现高版本的MOD服从API7开始，对多线程处理器有了较大的优化，负载均衡缺点：①即使加了pore也难以让bukkit插件正常运行②Sponge插件比bukkit要少很多③插件配置比bukkit插件难，汉化更难④启动慢可自定义功能较多 SpongeVanillaSponge端的纯净版优点：支持Sponge插件Sponge插件可在客户端中安装优化极强，占用内存少，配置需求低从API7开始，对多线程处理器有了较大的优化，负载均衡缺点：①即使加了pore也难以让大部分bukkit插件正常运行②Sponge插件比bukkit要少很多③插件配置比bukkit插件难，汉化更难④无法加入MOD可自定义功能较多 Glowstone（荧石端）优点：开源的bukkit服务端，开发者可通过这个制作属于自己的服务端内置对sponge插件所支持的插件缺点：未知 下载可以通过 MC Mirror。 一些资源相关介绍 Minecraft 官网 Minecraft 中国区(网易)官网 维基百科 - Minecraft) 论坛 Minecraft forum(官方论坛，英文) MCBBS(中文)) Minecraft 百度贴吧 Wiki Minecraft Wiki(英文) Minecraft Wiki （中文） 游戏资源 HMCL - Minecraft 启动器 Forge - 加载 mod OptiFine - 高清修复 CurseForge - mod 、资源包下载 MC Mirror MC Mod MinecraftXZ]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>游戏</tag>
        <tag>mod</tag>
        <tag>服务器</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Lambda 表达式不为人熟知的特性]]></title>
    <url>%2F2019%2F04%2F27%2Fjava-lambda%2F</url>
    <content type="text"><![CDATA[Lambda 表达式是 Java 8 的新语法，可以极大地简化代码，增强语言的表达力。这里不赘述 Lambda 表达式的语法，主要从一道题目出发来说 Lambda 表达式的一个特性。 从前阵子开始，坚持每天在 LeetCode 做一道题。这是前话。今天在做这道题的时候，碰到一个问题，记录下来备忘。 从题目说起题目本身很好理解：给几个区间，将其中重叠相交的合并，返回合并后的区间。 做法也不难：将区间按照”起点小的在前，起点一样的则终点小的在前”排序。 选定第一个区间 A，按序依次遍历剩下的区间 B，如果 B 的起点比 A 的终点小，则 A 和 B 可以合并。 不断重复这个选定第一个区间的操作，直至将所有可合并的区间进行合并。 最后返回剩下的区间即可。 按理说不难，做完之后，也能通过了。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public int[][] merge(int[][] intervals) &#123; Arrays.sort(intervals, (o1, o2) -&gt; &#123; if (o1[0] != o2[0]) &#123; return Integer.compare(o1[0], o2[0]); &#125; return Integer.compare(o1[1], o2[1]); &#125;); boolean[] vis = new boolean[intervals.length]; Arrays.fill(vis, true); for (int i = 0; i &lt; intervals.length; i++) &#123; if (!vis[i]) &#123; continue; &#125; for (int j = i + 1; j &lt; intervals.length; j++) &#123; if (intervals[j][0] &lt;= intervals[i][1]) &#123; vis[j] = false; if (intervals[i][1] &lt; intervals[j][1]) &#123; intervals[i][1] = intervals[j][1]; &#125; &#125; &#125; &#125; int count = 0; for (boolean v : vis) &#123; if (v) &#123; count++; &#125; &#125; int[][] ans = new int[count][]; for (int i = 0, j = 0; i &lt; intervals.length; i++) &#123; if (!vis[i]) &#123; continue; &#125; ans[j++] = intervals[i]; &#125; return ans;&#125; 不太理解的是 LeetCode 上的执行时间是 84 ms，已经战胜 28.32 % 的 java 提交记录。我左思右想，这已经是 O(N) 复杂度的解法(当然还有常数级别的优化空间)，难道还能有更高效的做法？ 效率差距的疑惑于是我看了一下别人的解法，大体上是一样的，复杂的也是 O(N)。因为一些细节上的处理，会有常数级别的差距，但应该不至于有这么大的差距才对。 一开始怀疑是数据量很大，在遍历的过程需要访问当前数据和之前的数据，可能是在这时发生了取数据的耗时操作。于是尝试把需要比较的数据用临时变量存储下来。结果发现耗时并没有什么变化。 最后实在想不出来，于是照着别人的代码，一点点改，边改边看执行时间。 最后发现是排序这里的 lambda 表达式造成了效率的差距。 Java 的 LambdaGoogle 搜索后看到了 Stack Overflow 上的这个提问 Java lambdas 20 times slower than anonymous classes。 可以看到 Lambda 表达式的一些特性： Lambda 表达式对应的类是在运行时动态生成的。运行时动态生成，并不是这里慢的原因。动态生成一个结构简单的类，比从外部资源加载同样的字节流要更快。 程序必须要加载用于生成 Lambda 类的框架，才能使用 Lambda 表达式。加载框架才是这里慢的原因。(Oracle JDK 使用 ASM 来实现。) 如果不考虑加载 Lambda 框架的时间，使用 Lambda 表达式的效率会比使用类高一点。 所以，程序使用 Lambda 表达式后慢的原因也就呼之而出了：LeetCode 执行提交的代码之前，没有使用到 Lambda 表达式。当执行我们的代码时，要先加载处理 Lambda 表达式的框架。加载框架的时间会算到程序的运行时间里。 进一步的验证虽然原理已经知道，但也要用代码从实际来验证一遍。 就像该回答中提到的，定义更多的 Lambda 表达式，也不会对运行时间有明显的影响。 我自己也做了一个实验：在程序的一次运行期间，多次执行”合并区间”的操作。每次都使用相同的数据，可以明显看到第一次执行的时间明显比后面每一次的时间都要长。这也验证了的确存在”加载 Lambda 框架”这个步骤的存在，以及这个加载过程也是主要的耗时操作。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wiki vs Blog]]></title>
    <url>%2F2019%2F04%2F22%2Fwiki-vs-blog%2F</url>
    <content type="text"><![CDATA[之前看到一篇文章，大意是说网上已经有太多太多的人在写着重复的文章。 所以很多东西其实只需要用 Wiki 来就来就行了。 当时深以为然，并探索了搭建 Wiki 的途径。 尝试了 Simiki。最后没有写下几篇 Wiki。 时至今日，又有了一些新的想法。 诚然，已经有非常多重复的文章在讲同一件事。 但最重要的，是自己在写文章的过程中对知识的梳理，最后形成的文章虽然也重要，但却不是最重要的。 因此，只要写文章的过程，有了自己的思考，这就是属于自己的文章；有查漏补缺以便能成文，这个过程也是一个学习提升的好机会，就是值得的。 更何况，有了那么多的文章，「站在前人的肩膀上」也许能看到一些不一样的风景。 这样看来，应该放弃 Wiki 这种形式，都采用 Blog 的形式，对于相关的内容可以采用专题的形式来组织即可。 starting a blog]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[域名]]></title>
    <url>%2F2019%2F04%2F06%2Fdomain%2F</url>
    <content type="text"><![CDATA[记录一下域名和服务器的故事。 2017-07-10 购买 yzbyzz.com 域名。ICP 备案、公安部备案。(公安部备案后，还收到了老家的网警打来的电话。用家乡话说搭建博客真的贼羞耻。) 2017-08-25 购买阿里云服务器，1 G 1 核，3 年只要 800。的确便宜，但是几乎没怎么用过。 2019-02-01 一个插曲，yzbyzzz.com 这个域名到期后没有续费。后面发现被别人注册了，还搞了个赌*网站。赶紧去注销 ICP 备案和公安部备案。 2019-03-11 购买 zhezhengcn.com 域名。ICP 备案。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写作这件小事]]></title>
    <url>%2F2019%2F04%2F05%2Fsomething-about-write%2F</url>
    <content type="text"><![CDATA[为什么要写作在我目前看来，写作有如下意义： Learning by teaching。一个东西如果不能用自己的话说出来，并让其他人明白，说明还没有真正的掌握。在写作的过程，可以不断地问自己，去深究各种问题，从而真正理解一个东西。 完善体系结构。把学习、思考的过程记录下来，每当有了新的体会和感悟，就可以继续补充文章，从而不断完善自己的知识体系。 锻炼文笔，提升表达能力。文字是很重要的传播信息的载体，掌握了写作能更好地达成共识、促进理解。 提升自己的影响力，形成「个人品牌」，给未来多一份可能。 写作历程大学开始写博客，那时候主要在 CSDN 和博客园。写的都是 ACM 的题解。现在看来，内容很水，文字也很稚嫩（虽然现在的文字也很稚嫩就是）。即便很水，写作也是三天打鱼两天晒网。就像学 ACM 算法的时候一样，不能善始善终。后来对 ACM 心灰意冷，就更加没有写作。 直到毕业后，才又重新拾起博客。看到 GitHub Page 这种极客范的博客，可定制性高，还不用自己买域名和服务器，就照着教程搭建。一开始用的是 Jekyll，在搭建的过程中发现 Hexo 更好用，就改成 Hexo。还记得那时候很多东西都不懂，像是 JavaScript、npm、Git 都是一知半解，只会照着教程敲命令，却不懂这些命令的意思。那个时候 Hexo 的功能也还比较简单，很多功能要实现都得自己硬编码，而不是框架自身支持的。几年过去，现在已经方便很多。比较遗憾的是，那个时候搭建博客的时候热情洋溢。但实际上博客却没写几篇，不能把自己这一路以来的心态变化和技术成长记录下来，有点可惜。 期间也有零零散散地在某云笔记里写写日记。由于是「日记」，所以基本上都是写过就算，自己都很少再去看，别人就更加不可能。也因此，写的时候总是东一句西一句，写到哪算哪，没什么逻辑可言。 大概是从 18 年 9 月开始，直到现在(2019 年 4 月)，做到每天写日记。偶尔哪天忘记，也会在后面补上。既然都能做到每天写日记，那每周把其中一些「见得人的文字」整理成一篇发出来，想必也不是那么的难。(希望这不是一个 Flag。) 最后的话想起 16 年就注册的公众号，直到现在也没发过一篇文章。这拖延症真的是很可怕。就从现在起，每周至少更新一篇文章，技术的、生活的都可以，发到博客还有微信公众号。掘金、简书、CSDN 这些平台就随缘吧。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>博客</tag>
        <tag>个人品牌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crontab 运行后不发送邮件]]></title>
    <url>%2F2019%2F03%2F10%2Fctonrab-do-not-send-email%2F</url>
    <content type="text"><![CDATA[crontab 执行命令后，如有输出到 stdout、stderr，相应的输出会通过邮件发送给用户。 如果命令有输出，但是却没有发送邮件，很可能是 crontab 或者 mail 的设置有问题。 问题crontab 执行命令后，没有发送邮件。查看 crontab 日志 /var/log/cron ，看到 12Mar 9 00:20:01 centos CROND[18856]: (test) CMD (sh /home/test/test.sh)Mar 9 00:20:01 centos CROND[18854]: (test) MAIL (mailed 48 bytes of output but got status 0x004b#012) 说明 crontab 发送邮件的时候出错了。再查看 mail 的日志 /var/log/maillog，看到 1Mar 9 00:20:01 centos postfix/sendmail[18860]: fatal: parameter inet_interfaces: no local interface found for ::1 解决经过网上搜索，发现是 Postfix 的配置问题。 默认的配置如下 1234567891011121314151617# The inet_interfaces parameter specifies the network interface# addresses that this mail system receives mail on. By default,# the software claims all active interfaces on the machine. The# parameter also controls delivery of mail to user@[ip.address].## See also the proxy_interfaces parameter, for network addresses that# are forwarded to us via a proxy or network address translator.## Note: you need to stop/start Postfix when this parameter changes.##inet_interfaces = all#inet_interfaces = $myhostname#inet_interfaces = $myhostname, localhostinet_interfaces = localhost# Enable IPv4, and IPv6 if supportedinet_protocols = all 修改方案一 12inet_interfaces = allinet_protocols = all 修改方案二 12inet_interfaces = localhostinet_protocols = ipv4 反思这个问题看起来不复杂，按部就班就能找到原因。 但实际解决过程中—— 发现 crontab 没有发送邮件 查看 crontab 日志 搜索 MAIL (mailed 48 bytes of output but got status 0x004b#012)，但是出来的很多结果都不符合我的问题。 想到可以看 mail 的日志 搜索 fatal: parameter inet_interfaces: no local interface found for ::1才发现是 Postfix 的配置问题。 这里其实暴露出了自己 Linux 知识体系的残缺不堪。由于缺乏完整的知识体系，只能依赖搜索引擎和别人的文章、经验。但是有些时候，不同的底层原因，会造成相同的表现，导致自己搜索了很久，还是不能找到真正的原因。 很多其他知识也是如此，如果没有对全局的理解，就只能不断重复这个 遇到小问题，经过或多或少的搜索、探究后找到答案。在这个过程中，除了解决当时的问题，更重要的是不断完善自己的知识体系——多思考、多记录，避免总是遇到同样的问题。这也是写文章最大的意义了吧。 RefCentOS 错误：sendmail: fatal: parameter inet_interfaces: no local interface found for ::1错误修复 sendmail: fatal: parameter inet_interfaces: no local interface found for ::1linux 配置定时任务 crontab 碰到的坑 sendmail]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>crontab</tag>
        <tag>email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[延迟满足感]]></title>
    <url>%2F2019%2F03%2F03%2Fdelay-of-gratification%2F</url>
    <content type="text"><![CDATA[听过很多道理，却依然过不好这一生知道该做什么，却没有去行动。 即便行动，也不能坚持。 即便坚持，也有可能目标、方法从一开始就是错的。 延迟满足感看番追剧玩游戏是一天，看书学习打代码也是一天。前者能马上就体会到愉悦，而且在体验的过程是轻松、没有压力的。后者则需要在体验的过程集中精力、注意力，收获还不能立竿见影。所以大多数人轻而易举地就选择了第一条路。 但是我们真的无法做到这种程度的集中吗？并不尽然吧。 以前看到一个问题：马上得到 10 元，和一周后得到 100 元，你会选择哪一个。只要不是现在身无分文又马上需要 10 元的情况，很多人都会选择 100 元吧。玩游戏就好比这能立刻兑现的 10 元，学习就好比一周后才能兑现的 100 元。当选择是 1 天 10 元 和 1 周 100 元时，我们能选择价值高的。如果当选择是 1 天 1 元和 1 年 10000 元时，我们是否还能做到选择价值高的？做不到的原因是因为我们觉得 1 年太长；抑或不清楚时间只要 1 年；抑或觉得时间不止 1 年；抑或不知道能得到 10000 元；抑或觉得得到的没有 10000 元？如果我们能想清楚这件事需要的成本和回报，这个成本对我们来说的代价相比回报对我们来说的价值如何，以及我们自己的期待，那是否就能做到了呢？ 这里其实牵扯到了价值观的问题。即我们看重的是什么，每个人眼里的 10000 元可能是不同的东西。彼之砒霜吾之蜜糖。真正知道自己想要的，并为之行动，而不是为了短期的利益而迷失目标。如果想要提升编程能力，那就当多读书多实践，而不是整天就想着玩来满足一时的愉悦。 有效的反馈知道了，也开始去行动了。但还是不能坚持。一个是有太多的诱惑很难抵抗。一个是在过程中没有体会到“满足”。这两者说到底还是要延迟满足感。这是必要的。除此之外，是否我们自己能人为创造反馈来“满足”内心的需求以便更好地推进。 设定目标，如果是大目标，一定要分割成多个小目标。每到达一个里程碑，就给自己一点奖励/激励，让大脑意识到每天的行动都是有意义的、有价值的。要把这些行动变成一种习惯，就像吃饭喝水那样自然。如果不吃饭就会饿，不喝水就会渴，不做这些事就会不自在。以目标为导向，以价值观、信念为支撑，用行动来践行。 知易行难水了这么久说了这么多，也是时候结束了。还是要继续探索：我真正想要的是什么，为此我愿意付出什么。觉得 Just do it这句话很有意思，如果写成 Just do IT 就可以用来自嘲：只是个做 IT 的。不管怎么说，just do IT。 —— 写于广州黄埔 2019.03.03 12:00 自从没有考试写作文后，就很少写这种纯粹的“议论文”了，还是要多练习。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018 总结]]></title>
    <url>%2F2019%2F02%2F19%2F2018-summary%2F</url>
    <content type="text"><![CDATA[一直以来，我都不是一个擅长反思的人，更准确地说是没有这个习惯。不反思就少了总结、提升的机会。希望以后每年都能做个总结，培养自己反思的习惯。 从阅读说起今年看了几本书：《如何阅读一本书》、《原则》、《软技能——代码之外的生存之道》、《被讨厌的勇气》。还有几本记忆不深就不提了。算是有所收获，不过还是缺乏行动。 说到阅读，不得不提“辉哥奇谭”这个公众号。自从知道这个公众号后，基本每天起床刷牙时都是看辉哥的文章。这一年从这里学习到不少思考的方式和角度。比如，读书最重要的不是把书完整地看一遍，而是从中获取到自己需要的知识，满足自己某方面的需求。《如何阅读一本书》中也提到：看到书中有好的东西后，一定要去践行。如果不能践行，很大可能是认同感还不足：嘴上说着很有道理，但是身体却还不肯行动。这也是所谓的“听了很多道理，却依然过不好这一身”。毕竟没有行动，谈何改变。知行合一才是最难，也是最重要的。 越发觉得阅读是一个绝佳的媒介——聆听其他人的想法。通过不同想法的碰撞，形成自己的三观，在实践中不断更新。与人谈心也是一个很好的方式，这也是目前我做的不好的地方。新的一年，要多读书多思考，多与人交流，不要固步自封。 人各有志这是一个拼命的时代：互联网行业盛行九九六：人人都在喊奋斗；诸如“你的同龄人正在抛弃你”之类的营销文更是层出不穷。然而人生之路，并非只有奋斗一条。努力也好，安逸也罢，都是个人选择，无可厚非。选择了安逸就接受平凡，既要安逸又要不凡是不存在的。最重要的是知道自己想要什么，为此需要付出什么、放弃什么。 于我而言，既然已经选择了留在广州，那就注定不会太轻松。如果留在了广州，还整天总想着看番、打机，那么为什么不回老家发展呢，岂不是更加轻松惬意。（当然，适当的娱乐是必需的，只是要劳逸结合，把握好度。）新的一年，要提高自己管理时间、分配精力的能力。 团队协作单打独斗总是很难走远的。团队的作用就是让每个人都发挥自己的长处，达到 1 + 1 &gt; 2 的作用。《原则》中提到一些观点：人与人大不相同。我们要理解并尊重这种差异，求同存异。寻找最好的答案，而不是自己能得出的最好答案。这也是我这一年的一个大变化。在工作中需要多和人沟通交流，而不是自己们闷着头干。遇到问题需要讨论时，不要为了争个高低而固执己见，而应该是寻求更好的解决方式，无论这个方案是谁提出来的。无论何时，要敢于承认自己的错误，承认自己知道的并不多，这样才能更好地学习和成长。另外，不要担心犯错，应该担心的是犯错后不能吸取教训以致重蹈覆辙。 术业有专攻这一年由于公司业务频繁调整，先后参与了两个应用 APP、几个小游戏/程序、一个游戏 APP 的开发。技术上主要负责后端开发，后期同时参与了游戏 APP 的客户端开发。服务端主要提供 HTTP、Socket 接口给前端/客户端调用；包括 Lua、C、Skynet 的游戏服务端，Java、Gradle、Spring Boot、Mybatis 的 Web 服务端，Java、Netty 的游戏服务端，Python、scrapy 的爬虫和运维脚本。游戏 APP 使用的是 Unity，涉及到 C#，主要负责资源的打包、更新、加载，用户游戏数据的读写。期间还偶尔客串 iOS 和前端，写一下 Object-C、Swift、JavaScript，基本属于打杂。 看起来像是做了挺多东西，但是仔细一想，由于赶工期，加上很多项目由于各种原因实际上并没有完成或者完成后运营的时间不长，在这个过程中，很多时候只是把东西“做出来了”，还没有经过太多的考验，所以很难说真的有能力做到这些东西，只能说有个概念这样能实现需求。这点也是我急需解决的问题：缺乏项目的长期运营/运维、持续开发/跟进的经验。 虽然说语言只是一门工具，重要的是实现需求、实现功能，真正地解决问题。但是每个语言都有自己的生态和工具链，这些东西的学习还是需要一定的成本的。我还是需要选定自己的方向，做到一专多长。新的一年，要静下心来好好提升技术。 尽人事听天命许多事情都有选择，只是往往事后我才懂得。还是要多去经历，多尝试，多体验。该做的想做的，就尽力去做好。即便最后失败，那也没有遗憾了。新的一年，希望能脱单吧。行动是要有的，但也不强求了。当然强求也强求不来。 最后还是要用我很喜欢的一句话来结尾：一个人的命运当然要靠自身的奋斗，但也要考虑历史的进程。希望在 2019 年开启崭新的篇章。 —— 写于广州市黄埔区 这篇博客从农历新年前（1.28）开始写，由于各种原因，拖延到了年后的元宵（2.19）才发布。新年的第一次打脸。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次 Unity 定位 bug]]></title>
    <url>%2F2019%2F01%2F13%2Fdebug-unity-charset-encoding%2F</url>
    <content type="text"><![CDATA[前言最近公司在开发一个对战游戏：服务端使用 Java + Netty + Spring，编辑器使用 IDEA；客户端使用 C# + Unity，编辑器使用 Unity Editor 和 Rider；通信方式使用 Socket，消息编解码使用 Protobuf。由于你懂的原因，加入了机器人。机器人的昵称、头像等信息是通过配置文件读取的。机器人的配置格式类似 {&quot;nickname&quot;: &quot;xxx&quot;, &quot;avatar&quot;: &quot;yyy&quot;}。 阶段性开发后，打包进行测试。 出现问题某天收到一个 bug 反馈，反馈的信息是一张游戏界面的截图：图上有玩家/机器人的头像和昵称，其中一个机器人（后面都简称为 R）的昵称是乱码。（简而言之，能看出来机器人 R 的头像，但是看不出来 R 的昵称是哪些字符。）很明显这是一道编 song 码 fen 题。 定位问题由于手头只有代码和配置文件，没有机器人头像的图片资源。所以先用 Python 写了个脚本把机器人配置文件里的头像都抓了下来。通过对比，定位到 R 头像的图片 url，再从 url 找到 R 的具体配置，并定位到乱码的字符。嗯，的确是个特殊字符。 重现问题把配置文件里机器人昵称都改成同样的昵称（那个不能正常显示的特殊字符），这样必定能看到字符在传输过程中的变化，也能看到是哪里出了问题。改好配置，运行游戏，可以看到画面上的字符的确不能正常显示。查看日志，在 （Mac 下的）Unity Editor 中，特殊字符显示为空白字符；在 Rider 中能正常显示。这就说明了服务端读取配置文件、Protobuf 编解码、Socket 数据传输的过程都没有问题。问题出现在 Unity 对特殊字符的处理上。 进一步确认问题：将特殊字符直接发到手机上，是可以正常显示的。但是在使用 Unity 写的游戏中，就显示为乱码了。 解决问题TODO：还暂未找到解决问题的方式。目前来看，应该是哪里需要再设置、配置一下。这里待更新。 后记说来惭愧，我定位问题到后的第一反应是甩锅：先丢出相关截图和说明，表明这不是自己的锅。作为一个开发，遇到问题的第一反应居然不是解决，而是想着怎么证明不是自己的锅。我大概是一个假的程序猿。 写下这篇博客只是为了水，以便完成两周一篇的目标。主要还是想让自己记住，保持对技术的热情和解决问题的兴奋。在遇到问题时，无论是不是自己的，都要敢于承担、善于探索解决。这样才能更快地成长，毕竟程序员就是在解决问题的过程中成长的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[就像每次学一门语言都会先写个 Hello World 程序，每次写博客也都要写一个 Hello World 文章。我已经记不清自己是第几次写这种文章。没错，我又一次想要更新博客，这次不知道能不能坚持下去。 以前也写过几段时间的博客，但都是三分钟热度、半途而废。大多数时候都是因为注意力被其他事情吸引过去（比如游戏、动漫），导致没有时间可以分配给写作，慢慢地也就淡忘了。现在几乎不玩游戏，动漫也看的少，我倒要看看这次会是什么原因导致停更。 这篇文章作为一个开始，为了让自己坚持下去，也趁着新年，给自己制定几个明确、可执行、可衡量的 Flag 目标： 早睡早起。 7 点半前醒，12 点半前睡。 7 点后的第一次睁眼就必须醒来，不能等到 7 点半闹钟响才醒。 起来后看点书。 坚持更新博客。每天都写一点，但每两周要更新一篇。 坚持每日微运动。每天抽出十分钟做点简单的运动。 每个月或每个季度更新一下这篇文章——也就是个人的目标。 无论工作日还是休息日这些目标都生效，只有回老家或者出去玩的时候是例外。另外，毕竟我还是人，不是机器。所以每个目标在每个月给自己两次偷懒的机会。如果偷懒超过限制，就得给自己一些惩罚。暂时想到的惩罚有： 在票圈发某宝口令红包。 不看动漫一周。 也许以后会想到更有效的惩罚，到时再更新。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>不断更新</tag>
        <tag>Flag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Java 中初始化 List 的五种方法]]></title>
    <url>%2F2018%2F11%2F02%2Fjava-init-list%2F</url>
    <content type="text"><![CDATA[Java 中经常需要使用到 List，下面简单介绍几种常见的初始化方式。 构造 List 后使用 List.add 初始化1234List&lt;String&gt; stringList = new LinkedList&lt;&gt;();stringList.add("a");stringList.add("b");stringList.add("c"); 这是最常规的做法，用起来不太方便。 使用 \{\{\}\} 双括号语法12345List&lt;String&gt; stringList = new LinkedList&lt;String&gt;()&#123;&#123; add("a"); add("b"); add("c");&#125;&#125;; 这种方式相对方便了一些。 外层的 {} 定义了一个 LinkedList 的匿名内部类。内层的 {} 的定义了一个实例初始化代码块。 这个代码块在初始化内部类时执行。所以这里相当于定义了一个匿名内部类，并使用 add 添加元素来初始化。 这种方式有几个缺点： 使用匿名内部类，会有效率上的损失。当然在大多数情况下，这点效率都是可接受的。 静态内部类持有所在外部类的引用。如果需要将 List 返回给到其他地方使用，可能造成内存泄漏。 使用 Arrays.asList1List&lt;String&gt; stringList = Arrays.asList("a", "b", "c"); 这种方式使用了 java.util.Arrays 的静态方法。写法上比之前的两种都更简洁，也没有构造匿名内部类的效率问题。 但也有几点需要注意： Arrays.asList 返回的是 Arrays 的静态内部类（静态内部类不持有所在外部类的引用）。 这个内部类继承自 AbstractList，实现了 RandomAccess，内部使用了一个数组来存储元素。但是不支持增删元素。这点需要注意。如果只是使用 Arrays.asList 来初始化常量，那么这点就不算什么问题了。 Arrays.asList 的参数如果是基本类型的数组时，需要留意返回值可能和你预期的不同。 123456int[] intArray = new int[]&#123;1, 2, 3&#125;;Integer[] integerArray = new Integer[]&#123;1, 2, 3&#125;; List&lt;int[] &gt; intArrayList = Arrays.asList(intArray);List&lt;Integer&gt; integerList = Arrays.asList(integerArray);List&lt;Integer&gt; integerList2 = Arrays.asList(1, 2, 3); 这里 Arrays.asList(intArray) 的返回值是 List&lt;int[]&gt; 而不是 List&lt;Integer&gt;。这一点也算不上问题，只是使用时需要留意。如果能在 Java 中做到尽量使用 List 和 Integer，尽量避免使用 int 等基本类型和 [] 这种较为底层的数据结构即可避免。 说点题外话：Java 终究还是不能称之为完全面向对象。毕竟保留了基本数据类型这种东西。诚然基本数据类型使用时比相应的封装类型效率要更高。但也给使用过程中带来了一些困惑：到底该用基本类型，还是封装类型，什么时候该用这个，什么时候该用哪个？虽然 Java 提供给了用户更多的选择，但有种将难题丢给用户的感觉。在我看来，Java 相比的 C++ 一个优点，就是很多事情有了限制，有较为明确清晰的定义，减少了模棱两可，更容易理解。但基本数据类型这里，感觉还是 Java 作为一门改善了 C++ 缺点的语言留下的一些影子。 虽然本文是在讲初始化 List，但这里的 \{\{\}\} 双括号语法同样可用于初始化 Map 等其他众多类型。相对而言，Arrays.asList 就只能用于初始化 List 类型了。 使用 Stream (JDK8)1List&lt;String&gt; list = Stream.of("a", "b", "c").collect(Collectors.toList()); 使用了 JDK8 的 Stream 来初始化。 单纯初始化 List，使用 Stream 有点大材小用了。 使用 Lists （JDK9）1List&lt;String&gt; list = Lists.newArrayList("a", "b", "c"); 这个和 Arrays.asList 一样简洁清晰。 参考Double Brace Initialization How to initialize List object in Java?]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>旧文补发</tag>
        <tag>Java</tag>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符集和字符编码]]></title>
    <url>%2F2018%2F05%2F18%2Fcharset-set-and-encoding%2F</url>
    <content type="text"><![CDATA[字符集字符集，从字面意思来讲，就是某些特定字符的集合。 ASCII 字符集包括了大小写英文字母、数字、英文标点符号和控制字符等在内的 128 个字符； GBK 字符集除了包括 ASCII 字符集中的所有字符，还包括了汉字和中文标点符号； Unicode 字符集除了包括 ASCII 字符集中的字符，还包括了中文字符、日文字符等各种各样的字符。 字符集除了指定其中包含的字符，还为每个字符分配了一个唯一的代码值（通常是数字）来代表该字符。 这个代码值就称之为该字符在该字符集中的码点。 在 ASCII 字符集中用 65 来表示字符 A ；Unicode 字符集中用 U+0041 来表示字符 A 。（其中 U+ 是 Unicode 的固定前缀，0041 是一个 16 进制数字。） 另一方面，也可以说字符A 在 ASCII 字符集中的码点是 65，在 Unicode 字符集中的码点则是 U+0041。 编码表应该是字符集的另一种叫法？ ASCII 字符集： 字符编码字符编码：将字符按照一定的规则，转换成一个二进制数字，保存到计算机中。以及一个二进制数字，通过怎样的规则，转换成一个对应的字符。 在某种字符集中，将一个字符保存到计算机中时，由于一个字符对应了一个唯一的码点，所以通常情况直接保存该码点即可（比如 ASCII 编码就直接保存了字符在 ASCII 字符集中的码点），但有些时候却不是这样。 比如 Unicode 字符集。 Unicode 字符集包含了很多字符。 Unicode 的码点可以分成 17 个代码级别(code plane)。 第一个代码级别称为基本的多语言级别(basic multilingual plane )，码点从 U+0000 到 U+FFFF ，其中包括经典的 Unicode 代码；其余的 16 个级别码点从U+10000 到 U+10FFFF, 其中包括一些辅助字符(supplementary character)。 123456789101 个基本的多语言级别U+0000 ~ U+FFFF (65536 个)剩余的 16 个级别U+10000 ~ U+1FFFFU+20000 ~ U+2FFFF...U+E0000 ~ U+EFFFFU+F0000 ~ U+FFFFFU+100000 ~ U+10FFFF 要表示从 U+0000 到 U+10FFFF的 17 * 65536 = 1,114,112 个字符，需要 3 个字节。 虽然 Unicode 字符集包括了这么多的字符，但是我们常用的字符却只占其中的一小部分。 以英文字符为例，用 1 个字节来表示就能比用 3 个字节来表示节省 2/3 的空间。 这对于主要使用英文的西方国家来说，是一个不容忽略的空间。 所以就有了 UTF-8、UTF-16 等不同的编码方式来将 Unicode 字符集中的字符编码成占据不同字节大小的数字存储到计算机中。 UTF-8 编码使用 1 ~ 3 个字节来表示一个 Unicode 字符： 1 个字节可以表示 2^7 = 128 个字符，与 ASCII 字符集对应。 2 个字节可以表示 2^(5+6) = 2048 个字符。 3 个字节可以表示 2^(4+6+6) = 65536 个字符。 Byte 1 Byte 2 Byte3 0xxx xxxx 110x xxxx 10xx xxxx 1110 xxxx 10xx xxxx 10xx xxxx Ref字符集和字符编码（Charset &amp; Encoding）– 吴秦（Tyler） 字符编码笔记：ASCII，Unicode 和 UTF-8 – 阮一峰 十分钟搞清字符集和字符编码 – cenalulu]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>旧文补发</tag>
        <tag>字符集</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 核心技术]]></title>
    <url>%2F2018%2F05%2F17%2Fjava-core%2F</url>
    <content type="text"><![CDATA[把书中一些自己不熟悉或者自己认为比较重要的知识点，做个简单的记录备忘。 第 3 章 Java 的基本程序设计结构浮点数的科学表示法1234567# 以 10 为底，尾数、指数都是十进制1.36e2 = 1.36E2 = 1.36 * 10^2 = 136# 以 2 为底，尾数是 16 进制，指数是十进制0x11p3 = 0x11P3 = 0x11 * 2^3 = 17 * 8 = 1360x1ap-1 = 0x1aP-1 = 0x1a * 2^-1 = 26 * 1/2 = 13 / 与 floorDiv，% 与 floorMod1234567891011121314151617181920212223（当 `/` 的操作数为整型时）`floorDiv` that returns the integer less than or equal to the quotientand the `/` operator that returns the integer closest to zero.`/` 返回的结果与实际的商相比更接近 0，即满足： abs（结果） &lt;= abs（实际的商）`floorDiv` 返回的结果小于等于实际的商。Examples:floorMod(12, 5) == 2, (12 / 5) == 2floorMod(-12, -5) == 2, (-12 / -5) == 2（-12.0 / 5 = 12.0 / -5 = -2.4）floorMod(-12, 5) == -3, (-12 / 5) == -2floorMod(12, -5) == -3, (12 / -5) == -2x % y = x - x / y * yx / y * y + x % y == xflorMod(x, y) = x - (floorDiv(x, y) * y)floorDiv(x, y) * y + floorMod(x, y) == x 数值类型之间的转换123456789101112131415161718192021222324252627 float -------&gt; double ^ -- -- ^ | |\ / | | . ./ . | / \ | . / . .byte ----&gt; short ----&gt; int --------&gt; long ^ | | char无损转换 可能丢失精度--&gt; -.-.&gt;^ ^| || .| || .丢失精度：int -&gt; floatlong -&gt; floatlong -&gt; double 位运算移位运算符 左操作数是 int 类型，右操作数模 32 。例如，1 &lt;&lt; 35 的值等同于 1 &lt;&lt; 3 或 8。 左操作数是 long 类型，右操作數要模 64。例如 5L &lt;&lt; 35 的值是 171798691840 ；5L &lt;&lt; 65 的值等于 5L &lt;&lt; 1 或 10。 &gt;&gt;&gt; 运算符会用 0 填充高位， 这与 &gt;&gt; 不同， 它会用符号位填充高位。 不存在 &lt;&lt;&lt; 运算符。 在 C/C++ 中，不能保证 &gt;&gt; 是完成算术移位（扩展符号位）还是逻辑移位（填充 0) 。实现者可以选择其中更高效的任何一种做法。 这意味着 C/C++ &gt;&gt; 运算符对于负数生成的结果可能会依赖于具体的实现。 Java 则消除了这种不确定性。 字符在 Java 中， char 类型描述了 UTF-16 编码中的一个代码单元。 字符串Java 中的 String 是不可变对象。 优点：编译器可以让字符串共享。 读取 / 比较字符串 比 修改字符串 多。 拼接字符串 可以使用 StringBuilder（线程不安全，效率高） 、 StringBuffer （线程安全，效率低）。 缺点：只修改字符串中的某些字符时不如 C/C++ 灵活。 1234567891011// JavaString s = "a string";System.out.println(s);// 拼接字符串s = "one part" + "." + "another part";System.out.println(s);// 修改某个字符后，生成了新字符串s = s.replace(".", ",");System.out.println(s); 12345678910111213// C++std::string s = "a string";std::cout &lt;&lt; s &lt;&lt; std::endl;std::string a = "one part";std::string b = ".";std::string c = "another part";s = a + b + c;std::cout &lt;&lt; s &lt;&lt; std::endl;// 在原字符串上修改s.replace(a.length(), b.length(), ",");std::cout &lt;&lt; s &lt;&lt; std::endl; 1234567891011121314151617181920212223// Cchar *s = "a string";puts(s);// 拼接字符串，比较麻烦char *a = "one part";char *b = ".";char *c = "another part";int al = strlen(a);int bl = strlen(b);int cl = strlen(c);char *tmp = new char[al + bl + cl + 1];strncpy(tmp, a, al);strncpy(tmp + al, b, bl);strncpy(tmp + al + bl, c, cl);tmp[al + bl + cl] = '\0';s = tmp;puts(s);// 直接修改某个字符s[al] = ',';puts(s); 1234// outputa stringone part.another partone part,another part 比较字符串使用 equals 或 equalsIgnoreCase 或 compareTo，不能用 ==（比较的是两个对象指向的地址是否相同）。 Java 中对字符串的 + 运算进行了重载，却没有对 == 进行重载。 如果重载了 == ，那包括字符串在内的所有对象都将用 == 来判断是否相等。 像现在 == 用来判断指向的地址是否，其实很少用？ 获取长度 length 获取字符串中有多少个 char，即字符串用 UTF-16 编码时，需要的单元数量（一个单元 2 个字节） codePointCount 获取字符串的实际长度，即字符串中有多少个字符 / Unicode 码点。 码点、字符集、字符编码的一些概念见 0518 字符集和字符编码。 123456789101112131415161718192021String s = "\uD835\uDD46";// 𝕆(U+1D546) 需要两个代码单元System.out.println("s=" + s);System.out.println("length=" + s.length());System.out.println("codePointCount=" + s.codePointCount(0, s.length()));for (int i = 0; i &lt; s.length(); i++) &#123; System.out.println(i + ":" + s.charAt(i) + ", " + (int)s.charAt(i));&#125;int[] codePoints = s.codePoints().toArray();for (int i = 0; i &lt; codePoints.length; i++) &#123; System.out.println(i + ":" + codePoints[i]);&#125;/*s=𝕆length=2codePointCount=10:?, 553491:?, 566460:120134*/ 尽量避免使用 char 类型和 String 的 charAt 方法，因为它们太底层了。 控制台输入 Scanner 1234Scanner in = new Scanner(System.in);in.next();in.nextInt();... Console ，输入是不可见的 如果有可能进行交互操作，就通过控制台窗口为交互的用户返回一个 Console 对象， 否则返回 null。对于任何一个通过控制台窗口启动的程序都可使用 Console 对象 。否则， 其可用性将与所使用的系统有关。 123Console cons = System.console();String username = cons.readLine("Username: ");char[] passwd = cons.readPassword("Password: "); 格式化字符串复用参数的方法 采用一 个格式化的字符串指出要被格式化的参数索引。索引必须紧跟在 % 后面， 并以$ 终止。 参教索引值从 1 开始 。 12System.out.printf("a=%1$04d b=%2$s c=%3$.2f d=%2$s\n", 12, "STR", 9.87);//a=0012 b=STR c=9.87 d=STR 使用 &lt; 标志，它指示前面格式说明中的参数将被再次使用 12System.out.printf("a=%1$04d b=%2$s b=%&lt;s c=%3$.2f c=%&lt;.4f\n", 12, "STR", 9.87);//a=0012 b=STR b=STR c=9.87 c=9.8700 第 4 章 对象与类类之间的关系 依赖 uses-a 聚合 has-a 继承 is-a staticJava 中的静态域与静态方法在功能上与 C++ 相同。但是， 语法书写上却稍有所不同。在 C++ 中， 使用 :: 操作符访问自身作用域之外的静态域和静态方法， 如 Math::PI。 术语 static 有一段不寻常的历史： 起初， C 引入关键字 static 是为了表示退出一个块后依然存在的局部变量。在这种情况下， 术语 static 是有意义的：变量一直存在 ，当再次进入该块时仍然存在。 随后，static 在 C 中有了第二种含义，表示不能被其他文件访问的全局变量和函数。 为了避免引入一个新的关键字， 关键字 static 被重用了。 最后，C++ 第三次重用了这个关键字， 与前面赋予的含义完全不一样， 这里将其解释为：属于类且不属于类对象的变量和函数。 这个含义与 Java 相同。 方法参数 call by …call by 描述各种程序设计语言（不只是 Java) 中方法参数的传递方式： 按值调用 (call by value) 表示方法接收的是调用者提供的值。 按引用调用 (call by reference) 表示方法接收的是调用者提供的变量地址。 按名调用 (call by name)，Algol 程序设计语言是最古老的高级程序设计语言之一， 它使用的就是这种参数传递方式。不过，这种传递方式已经成为历史。 一个方法可以修改传递引用所对应的变量值， 而不能修改传递值调用所对应的变量值。Java 程序设计语言总是采用按值调用。对象引用是按值传递的。 基本数据类型：形参改变，不影响实参。 对象引用： 同样有“形参改变，不影响实参”，即将形参引用了其他对象，实参还是引用原来的对象。 但是形参初始时和实参的值相等，即引用了相同的对象，通过形参对被引用的对象进行修改，通过实参来访问被引用对象时，相应的值也会变化。 Java 中方法对参数的影响 一个方法不能修改一个基本数据类型的参数 （即数值型或布尔型）。 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。 C++ 中有值调用和引用调用。引用参数使用 &amp;，可以达到在函数中改变参数所引用的对象。 变量初始化默认值 局部变量必须初始化后才能使用 类的变量，如果没有初始化，会有默认值（0, false, null） 如何初始化 在构造器中设置值 在声明中赋值 在初始化块中赋值 12345678910class Cls &#123; &#123; // 对象初始化块 // 每次创建一个对象，都会执行该代码块 &#125; static &#123; // 静态初始化块 // 仅在类第一次加载时，执行 &#125;&#125; 调用构造器的处理过程 1 ) 所有数据域被初始化为默认值 (0、 false 或 null 。) 2 ) 按照在类声明中出现的次序， 依次执行所有域初始化语句和初始化块 3 ) 如果构造器第一行调用了第二个构造器， 则执行第二个构造器主体 4 ) 执行这个构造器的主体 this 类实例方法：引用方法的隐式参数 1234567class Cls &#123; private int a; public setA(int a) &#123; // this 隐式参数，调用 setA 方法的对象 this.a = a; &#125;&#125; 构造函数的第一条语句：调用同一个类的其他构造函数 123456789class Cls &#123; Cls() &#123; this("a", 3); //... &#125; Cls(String a, int b) &#123; //... &#125;&#125; 查找类文件假设类路径（class path）设置为 /home/user/classdir:.:/home/user/archives/archives.jar。 当要查找 com.domain.core.NewClass 类文件时 Java 虚拟机 jre/ lib 和 jre/lib/ext 目录下的归档文件中所存放的系统类文件 /home/user/classdir/com/domain/core/NewClass.class 从当前目录开始 com/domain/core/NewClass.class com/domain/core/NewClass.class inside /home/user/archives/archive.jar 编译器 确认导入的包中，是否有多个地方包含了类文件 检查源文件是否比类文件新，是否需要重新编译源文件生成类文件 文档注释以 /** 开始，以 */ 结束的多行注释。 每一行前面的 * 不是必须的。 注释采用自由格式文本（free-form text）： HTML 修饰符 强调 &lt;em&gt;...&lt;/em&gt; 着重强调 &lt;strong&gt;…&lt;/strong&gt; 图像 &lt;img…&gt; 等宽代码 {@code …} 分类 类注释 方法注释 变量描述 @param 返回值描述 @return 异常描述 @throws 域注释 只需要对公有域 （通常指的是静态常量）建立文档 通用注释 通用标记：以 @ 开头 @author @version @since @deprecated @see / @link 包与概述注释 第 5 章 继承一个对象变量可以指示多种实际类型的现象被称为多态 (polymorphism)。 在运行时能够自动地选择调用哪个方法的现象称为动态绑定 (dynamic binding)。 在 Java 中，不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征 ， 可以将它标记为 final 。 在 C++ 中需要声明虚函数。 动态绑定的限制 子类覆盖方法的返回值类型必须是超类方法的返回值的子类型（包括相同）。 覆盖方法的时候，子类方法不能低于超类方法的可见性。 final 修饰类：类不可被继承，类中的方法都成为 final 修饰方法：方法不可被子类覆盖 修饰域：数据域在初始化后不能再被修改 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;class A &#123;public: void outA() &#123; puts("A.outA"); &#125; virtual void outA2() &#123; puts("A.outA2"); &#125;&#125;;class B: public A &#123;public: void outA() &#123; puts("B.outA"); &#125; void outA2() &#123; puts("B.outA2"); &#125; void outB() &#123; puts("B.outB"); &#125;&#125;;int main() &#123; A* a = new B(); a-&gt;outA(); a-&gt;outA2(); ((B*)a)-&gt;outB(); return 0;&#125;///A.outAB.outA2B.outB 访问修饰符 public 所有类可见 protected 本包和所有子类可见 ( ) default 本包可见 private 仅本类可见 Java 实现 equals 的一些基本要求 自反性：对于任何非空引用 x，x.equals(x) 应该返回 true 对称性：对于任何引用 x 和 y，当且仅当 x.equals(y) 返回 true，y.equals(x) 也应该返回 true 传递性：对于任何引用 x、y 和 z，如果 x.equals(y) 返回 true，且 y.equals(z) 返回 true，则 x.equals(z) 也应该返回 true 一致性：如果 x 和 y 引用的对象没有发生变化，反复调用 x.eqals(y) 应该返回同样的结果 对于任何非空引用 x，x.equals(null) 应该返回 false 1234567891011121314151617181920212223242526272829303132333435public class TestExtends &#123; public static void main(String[] args) &#123; A a = new B(); a.outA(); ((B) a).outB(); System.out.println((a instanceof A) + ""); System.out.println((a instanceof B) + ""); System.out.println(a.getClass() == A.class); System.out.println(a.getClass() == B.class); &#125;&#125;class A &#123; public void outA() &#123; System.out.println("A.outA"); &#125;&#125;class B extends A &#123; @Override public void outA() &#123; System.out.println("B.outA"); &#125; public void outB() &#123; System.out.println("B.outB"); &#125;&#125;//B.outAB.outBtruetruefalsetrue 如何写 equals(Object otherObject) 显式参数命名为 otherObject, 稍后需要将它转换成另一个叫做 other 的变量。 检测 this 与 otherObject 是否引用同一个对象： if (this = otherObject) return true; 这条语句只是一个优化。 实际上， 这是一种经常采用的形式。 因为计算这个等式要比一 个一个地比较类中的域所付出的代价小得多。 检测 otherObject 是否为 null , 如果为 null , 返回 false。 这项检测是很必要的。 if (otherObject = null) return false; 比较 this 与 otherObject 是否属于同一个类。 如果 equals 的语义在每个子类中有所改变， 就使用 getClass 检测： if (getClass() != otherObject.getCIassO) return false; 如果所有的子类都拥有统一的语义， 就使用 instanceof 检测： if (!(otherObject instanceof ClassName)) return false; 将 otherObject 转换为相应的类类型变量： ClassName other = (ClassName) otherObject 现在开始对所有需要比较的域进行比较了。使用 == 比较基本类型域，使用 equals 比较对象域。如果所有的域都匹配，就返回 true; 否则返回 false。 12return fieldl == other.field &amp;&amp; Objects.equa1s(fie1d2, other.field2) 如果在子类中重新定义 equals, 就要在其中包含调用 super.equals(other) 函数可变个数参数 可变个数参数，应该是参数列表的最后一个参数 在函数中引用这些可变个数的参数时，以数组的形式来引用 除了传递不定个数的参数外，也可以用数组来传递给可变个数参数 1234567891011121314151617181920212223242526272829static void multipart(String s, int a, Object... values) &#123; System.out.println("s=" + s); System.out.println("a=" + a); System.out.println("values.getClass=" + values.getClass()); System.out.println("values instanceOf Object[] =" + (values instanceof Object[])); System.out.println(Arrays.toString(values)); System.out.println();&#125;multipart("string", 10, "one", 2, "three", 4.0);multipart("string", 10, new Object[]&#123;"one", 2, "three", 4.0&#125;);multipart("string", 10);///s=stringa=10values.getClass=class [Ljava.lang.Object;values instanceOf Object[] =true[one, 2, three, 4.0]s=stringa=10values.getClass=class [Ljava.lang.Object;values instanceOf Object[] =true[one, 2, three, 4.0]s=stringa=10values.getClass=class [Ljava.lang.Object;values instanceOf Object[] =true[] 枚举1234567891011121314151617181920212223242526272829303132public enum ProgramLanguage &#123; CPP("C++", 1), JAVA("Java", 2); private String lang; private int type; ProgramLanguage(String lang, int type) &#123; this.lang = lang; this.type = type; &#125; public static ProgramLanguage valueOf(int type) &#123; switch (type) &#123; case 1: return CPP; case 2: return JAVA; default: return null; &#125; &#125;&#125; ProgramLanguage language; language = ProgramLanguage.CPP; System.out.println(language); language = ProgramLanguage.valueOf(1); System.out.println(language); language = ProgramLanguage.valueOf("CPP"); System.out.println(language); language = Enum.valueOf(ProgramLanguage.class, "CPP") Class 类对象程序运行期间， Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识。 这个信息跟踪着每个对象所属的类。 虚拟机利用运行时类型信息选择相应的方法执行。 然而，可以通过专门的 Java 类访问这些信息。保存这些信息的类被称为 Class, 这个名字很容易让人混淆。 12345678ClassName obj = new ClassName();1. obj.getClass();2. Class.forName(ClassName);3. ClassName.class 一个 Class 对象实际上表示的是一个类型， 而这个类型未必一定是一种类。 例如， int 不是类， 但 int.class 是一个 Class 类型的对象。 在启动时， 包含 main 方法的类被加载。 它会加载所有需要的类。 这些被加栽的类又要加载它们需要的类。 反射java.lang.reflect Field：域 getName getModifiers getType Method：方法 getName getModifiers getParameterTypes getReturnType Constructor：构造器 getName getModifiers getParameterTypes java.lang.class getFields getMethods getConstructors 第 6 章 接口、lambda 表达式与内部类接口 方法自动被设置为 public 域自动被设置为 public static final JDK 8，可以有静态方法 可以为接口提供一个默认实现，使用 default 接口中有很多个方法，可以都有默认实现。使用接口时，只需要覆盖其中关心的方法即可，无需每个方法都手动写一个“空实现” 接口增加方法后，原有的实现类不用实现新方法，仍可使用 标记接口 tagging interface / 记号接口 marker interface标记接口不包含任何方法；它唯一的作用就是允许在类型查询中使用 instanceof。比如 Cloneable。clone 方法中，调用域的 clone 方法时，需要判断相应的域是否为 null。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package test.zz;/** * TestClone * * @author zz * @date 2018/5/28 */public class TestClone &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Clone2 clone2 = new Clone2(); Clone2 clone21 = clone2.clone(); &#125;&#125;class Addr implements Cloneable &#123; @Override public Addr clone() throws CloneNotSupportedException &#123; System.out.println("Addr.clone - 1"); return (Addr) super.clone(); &#125;&#125;class Clone1 implements Cloneable &#123; private String name; private Addr addr; Clone1() &#123; &#125; Clone1(String name) &#123; this.name = name; this.addr = new Addr(); &#125; @Override public String toString() &#123; return "&#123; name:" + name + ", addr:" + addr + " &#125;"; &#125; @Override public Clone1 clone() throws CloneNotSupportedException &#123; System.out.println("Clone1.clone - 1"); Clone1 clonee = (Clone1) super.clone(); clonee.addr = addr == null ? null : addr.clone(); //////// !!!!!!!!!!! System.out.println("Clone1.clone - 2"); return clonee; &#125;&#125;class Clone2 extends Clone1 implements Cloneable &#123; private Clone1 clone1; @Override public Clone2 clone() throws CloneNotSupportedException &#123; System.out.println("Clone2.clone - 1"); return (Clone2) super.clone(); &#125;&#125; 所有数组类型都有一个 public 的 clone 方法， 而不是 protected: 可以用这个方法 建立一个新数组， 包含原数组所有元素的副本。 lambda 表达式lambda 表达式是一个可传递的代码块， 可以在以后执行一次或多次。 带参数变量的表达式就被称为 lambda 表达式。 形式上参数，箭头，表达式 (params…) -&gt; { code block } 括号 参数仅有一个，且类型可被自动推导出来，可省略括号和类型 参数不是一个（包括 0 个），不能省略括号 若类型可被自动推导出来，可省略。 代码块 仅有一条语句，可省略大括号 返回值 代码块中的最后一条语句会作为返回值返回（无需显式使用 return） 如果代码块中存在分支（if else），每个分支都必须有返回值 返回值类型会自动推导，无需指定 定义上 一个代码块 参数 自由变量的值，非参数而且不在代码块中定义的变量 lambda 表达式中捕获的变量必须实际上是最终变量 ( effectively final 。) 实际上的最终变量是指， 这个变量初始化之后就不会再为它赋新值。 函数式接口对于只有一个抽象方法的接口， 需要这种接口的对象时， 就可以提供一个 lambda 表达 式。 这种接口称为函数式接口 (functional interface )。 lambda 表达式最终会被转换为函数式接口。本质上是函数式接口的简写，一个语法糖。 使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package test.zz;import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;/** * TestTimer * * @author zz * @date 2018/5/28 */public class TestTimer &#123; public static void main(String[] args) throws InterruptedException &#123; ActionListener listener; Timer timer; listener = new TimerPrinter(); timer = new Timer(1000, listener); timer.start(); Thread.sleep(5000); timer.stop(); listener = new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println("[[2]] actionPerformed.event=" + e); &#125; &#125;; timer = new Timer(1000, listener); timer.start(); Thread.sleep(5000); timer.stop(); listener = event -&gt; &#123; System.out.println("[[3]] actionPerformed.event=" + event); &#125;; timer = new Timer(1000, listener); timer.start(); Thread.sleep(5000); timer.stop(); &#125;&#125;interface Func &#123; void test(String s, int b);&#125;class TimerPrinter implements ActionListener &#123; @Override public void actionPerformed(ActionEvent event) &#123; System.out.println("[[1]] actionPerformed event=" + event); &#125;&#125;////////[[1]] actionPerformed event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571207103,modifiers=] on javax.swing.Timer@266267b2[[1]] actionPerformed event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571208108,modifiers=] on javax.swing.Timer@266267b2[[1]] actionPerformed event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571209112,modifiers=] on javax.swing.Timer@266267b2[[1]] actionPerformed event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571210113,modifiers=] on javax.swing.Timer@266267b2[[2]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571212097,modifiers=] on javax.swing.Timer@225de7a6[[2]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571213101,modifiers=] on javax.swing.Timer@225de7a6[[2]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571214104,modifiers=] on javax.swing.Timer@225de7a6[[2]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571215106,modifiers=] on javax.swing.Timer@225de7a6[[3]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571217104,modifiers=] on javax.swing.Timer@3b912d4a[[3]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571218108,modifiers=] on javax.swing.Timer@3b912d4a[[3]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571219111,modifiers=] on javax.swing.Timer@3b912d4a[[3]] actionPerformed.event=java.awt.event.ActionEvent[unknown type,cmd=null,when=1527571220114,modifiers=] on javax.swing.Timer@3b912d4a 这里参数的本质是一个接口，有几种方式实现： 定义一个类实现该接口，实例化一个该类的对象作为参数 定义一个匿名类，直接在参数处定义该类 当接口中仅有一个抽象方法时，可使用 lambda 表达式的形式 有时候，并不需要定义新的 lambda 表达式，而是使用已有的类方法。 object::instanceMethod Class::static Method Class::instanceMethod 1234567aString::compareTo == x -&gt; aString.compareTo(x)this::equals == x -&gt; this.equals(x)System.out::prinrln == x -&gt; System.out.println(x)Math::pow == (x, y) -&gt; Math.pow(x, y)String::equals == (x, y) -&gt; x.equals(y) 函数式接口只有一个抽象方法的接口，使用 @FunctionalInterface 标记 如果无意中增加了一个非抽象方法，编译器会产生一个错误消息 javadoc 文档会指出这个接口是一个函数式接口 第 7 章 异常、断言和日志捕获还是抛出异常 知道如何处理异常，就应该捕获 不知道怎样处理，就抛出异常继续传递 子类方法抛出的异常不能超过父类方法声明的范围 异常继承12345678910 Throwable | +------------+------------+ | | Error Exception(uncheckd exception) | +------------+------------+ | | RuntimeException other excpetion (uncheckd) (checked) 第 8 章 泛型程序设计&lt;T extends BoundingType&gt;表示 T 应该是绑定类型的子类型(subtype)。T 和绑定类型可以是类， 也可以是接口。选择关键字 extends 的原因是更接近子类的概念， 并且 Java 的设计者也不打算在语言中再添加一个新的关键字(如 sub)。 一个类型变量或通配符可以有多个限定， 例如: T extends Comparable &amp; Serializable。限定类型用“ &amp; ” 分隔， 而逗号用来分隔类型变量。 在 Java 的继承中， 可以根据需要拥有多个接口超类型， 但限定中至多有一个类。 如果用 一个类作为限定， 它必须是限定列表中的第一个。 Java 泛型转换的事实: 虚拟机中没有泛型， 只有普通的类和方法。 所有的类型参数都用它们的限定类型替换。 桥方法被合成来保持多态。 为保持类型安全性， 必要时插人强制类型转换。 消除编译器警告 @SuppressWamings(&quot;unchecked&quot;) @SafeVarargs 123456class Pair&lt;T&gt; &#123; T first; T second; // get &amp; set&#125; Manager 是 Employee 的子类 Pair&lt;Manager&gt; 不是 Pairt&lt;Employee&gt; 的子类 Piar&lt;Manager&gt; 和 Piar&lt;Employee&gt; 是 Piar&lt;? Extends Employee&gt; 的子类 泛型最基本的用法 &lt;T&gt; void func(List&lt;T&gt; list) 为什么要有 &lt;T extends Employee&gt; void func(List&lt;T&gt; list、void func(List&lt;? extends Employee) 以便使用 Employee 的方法 让 Employee 的子类 Manager 对应的 List&lt;Manager&gt; 也能作为参数 带有子类型限定的通配符可以从泛型对象读取。 为什么要有 void func(List&lt;? super Employee&gt; list) 带有超类型限定的通配符可以向泛型对象写入 123456789101112131415161718192021// okPair&lt;? extends Employee&gt; employeePair = new Pair&lt;Manager();// okEmployee employee = employeePair.getFirst();// error: setFirst(? extends Employee) 不能确定使用哪个// 编译器只知道需要某个 Employee 的子类型，但不知道具体是什么类型。 它拒绝传递任何特定的类型。 employeePair.setFirst(new Manager());// --// okPair&lt;? super Manager&gt; managerPair = new Pair&lt;Manager();// okObject object = managerPair.getFirst();// ok managerPair.setFirst(new Manager()); 第 9 章 集合Iterator ​ next ​ hasNext ListIterator extends Iterator ​ add ​ remove add 方法只依赖于迭代器的位置， 而 remove 方法依赖于迭代器的状态。 LinkedHashMap：LinkedHashMap 相比 HashMap，额外多了一个链表“按照一定的顺序”记录 Map 中的 key LinkedHashMapcK, V&gt;(initialCapacity, loadFactor, false) false：按照插入顺序 LinkedHashMapcK, V&gt;(initialCapacity, loadFactor, true) true：按照访问顺序 LinkedHashMap 调用 put/putAll 插入新元素后调用 removeEldestEntry。如果 removeEldestEntry 返回 true，则会删除该元素。可以利用这个实现自己的子类来达到实现一个 LRU 的缓存。 123protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; 视图Arrays/Collections 构造一个视图，在视图上的修改会反映在原始集合/数组上。 123456789String[] array = new String[]&#123;"a", "b", "c"&#125;;List&lt;String&gt; list = Arrays.asList(array);System.out.println(Arrays.toString(array));System.out.println(list);list.set(0, "new");System.out.println(Arrays.toString(array));System.out.println(list); 1234[a, b, c][a, b, c][new, b, c][new, b, c]]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>旧文补发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Spring Boot 中使用 Redis]]></title>
    <url>%2F2018%2F05%2F06%2Fspring-boot-use-reids%2F</url>
    <content type="text"><![CDATA[在 Spring Boot 中 使用 Redis本文中的代码见 spring-boot-redis。 Redis 本身的一些概念Redis 支持的数据结构 String 字符串 Hash 字典 List 列表 Set 集合 Sorted Set 有序集合 String 和 Hash 的对比String 实际是就是一个 Key - Value 的映射； Hash 就是一个 Key - （Key - Value） 的两层映射。 12345678910111213# redis-cli# Redis 中命令不区分大小写。这里命令使用小写，仅在特别的地方用大写。# 参数使用“大写+下划线”的方式。# Stringset KEY VALUEget KEY# Hashhset HASH_NAME KEY VALUEhget HASH_NAME KEYhMset HASH_NAME KEY0 VALUE0 KEY1 VALUE1 ...hMget HASH_NAME KEY0 KEY1 ... STACK OVERFLOW 上一个对 String 和 Hash 的讨论 对于一个对象是把本身的数据序列化后用 String 存储，还是使用 Hash 来分别存储对象的各个属性： 如果在大多数时候要访问对象的大部分数据：使用 String 如果在大多数时候只要访问对象的小部分数据：使用 Hash 如果对象里面还有对象这种结构复杂的，最好用 String。否则最外层用 Hash，里面又将对象序列化，两者混用可能导致混乱。 Spring Boot 添加 Redis 的配置 以 gradle 为例。 修改 build.gradle 1compile(&quot;org.springframework.boot:spring-boot-starter-data-redis&quot;) 修改 application.yml 123456789101112131415161718spring: # redis redis: ​ host: 127.0.0.1 ​ # 数据库索引（默认为0） ​ database: 0 ​ port: 6379 ​ password: PASSWORD ​ # 连接池中的最大空闲连接 ​ pool.max-idle: 8 ​ # 连接池中的最小空闲连接 ​ pool.min-idle: 0 ​ # 连接池最大连接数（使用负值表示没有限制） ​ pool.max-active: 8 ​ # 连接池最大阻塞等待时间（使用负值表示没有限制） ​ pool.max-wait: -1 ​ # 连接超时时间（毫秒） ​ timeout: 0 添加 RedisConfig 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package zz.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.extern.slf4j.Slf4j;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;/** * RedisConfig * * @author zz * @date 2018/5/7 */@Configuration@EnableCaching@Slf4jpublic class RedisConfig extends CachingConfigurerSupport &#123; @Bean public KeyGenerator wiselyKeyGenerator() &#123; ​ return new KeyGenerator() &#123; ​ private static final String SEPARATE = ":"; @Override public Object generate(Object target, Method method, Object... params) &#123; log.debug("+++++generate"); StringBuilder sb = new StringBuilder(); sb.append(target.getClass().getName()); sb.append(SEPARATE).append(method); for (Object obj : params) &#123; sb.append(SEPARATE).append(obj); &#125; return sb.toString(); &#125; &#125;; &#125; /** * https://www.jianshu.com/p/9255b2484818 * * TODO: 对 Spring @CacheXXX 注解进行扩展：注解失效时间 + 主动刷新缓存 */ @Bean public CacheManager cacheManager(@SuppressWarnings("rawtypes") RedisTemplate redisTemplate) &#123; log.debug("++++cacheManager"); RedisCacheManager redisCacheManager =new RedisCacheManager(redisTemplate); redisCacheManager.setTransactionAware(true); redisCacheManager.setLoadRemoteCachesOnStartup(true); // 最终在 Redis 中的 key = @Cacheable 注解中 'cacheNames' + 'key' redisCacheManager.setUsePrefix(true); // 所有 key 的默认过期时间，不设置则永不过期 // redisCacheManager.setDefaultExpiration(6000L); // 对某些 key 单独设置过期时间 // 这里的 key 是 @Cacheable 注解中的 'cacheNames' Map&lt;String, Long&gt; expires = new HashMap&lt;&gt;(10); // expires.put("feedCategoryDto", 5000L); // expires.put("feedDto", 5000L); redisCacheManager.setExpires(expires); return redisCacheManager; &#125; // value serializer private Jackson2JsonRedisSerializer getJackson2JsonRedisSerializer() &#123; Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); return jackson2JsonRedisSerializer; &#125; private GenericJackson2JsonRedisSerializer getGenericJackson2JsonRedisSerializer() &#123; return new GenericJackson2JsonRedisSerializer(); &#125; /** * * Once configured, the template is thread-safe and can be reused across multiple instances. * -- https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/ */ @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123; log.debug("++++redisTemplate"); StringRedisTemplate template = new StringRedisTemplate(factory); // key serializer StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); RedisSerializer valueRedisSerializer; // -- 1 Jackson2JsonRedisSerializer // valueRedisSerializer = getJackson2JsonRedisSerializer(); // -- 2 GenericJackson2JsonRedisSerializer valueRedisSerializer = getGenericJackson2JsonRedisSerializer(); // set serializer template.setKeySerializer(stringRedisSerializer); template.setValueSerializer(valueRedisSerializer); template.setHashKeySerializer(stringRedisSerializer); template.setHashValueSerializer(valueRedisSerializer); template.afterPropertiesSet(); return template; &#125;&#125; RedisConfig 中定义了三个函数，主要作用如下： wiselyKeyGenerator：定义了一个生成 Redis 的 key 的方法。如下文使用了 @Cacheable 注解的地方，可以指定 key 的生成方法使用我们这个函数。 cacheManager：定义了对 Redis 的一些基本设置。 redisTemplate：对我们要使用的 RedisTemplate 做一些设置。主要是确定序列化方法。 RedisTemplate 设置序列化器Spring Redis 虽然提供了对 list、set、hash 等数据类型的支持，但是没有提供对 POJO 对象的支持，底层都是把对象序列化后再以字节的方式存储的。 因此，Spring Data Redis 提供了若干个 Serializer，主要包括： JdkSerializationRedisSerializer： 默认的序列化器。序列化速度快，生成的字节长度较大。 OxmSerializer： 生成 XML 格式的字节。 StringSerializer： 只能对 String 类型进行序列化。 JacksonJsonRedisSerializer：以 JSON 格式进行序列化。 Jackson2JsonRedisSerializer：JacksonJsonRedisSerializer 的升级版。 GenericJackson2JsonRedisSerializer：Jackson2JsonRedisSerializer 的泛型版。 RedisTemplate 中需要声明 4 种 serializer（默认使用的是 JdkSerializationRedisSerializer）： keySerializer ：对于普通 K-V 操作时，key 采取的序列化策略 valueSerializer：value 采取的序列化策略 hashKeySerializer： 在 hash 数据结构中，hash-key 的序列化策略 hashValueSerializer：hash-value 的序列化策略 无论如何，建议 key/hashKey 采用 StringRedisSerializer。 by Spring-data-redis: serializer实例 我们设置了 serializer 后，读写 Redis 要使用同一种 serizlizer，否则会读不出之前用不同 serializer 写入的数据。 也就是设置 valueSerializer 为GenericJackson2JsonRedisSerializer，然后写入了数据。后面要读数据的时候，如果将 valueSerializer 又设置成了 Jackson2JsonRedisSerializer，那么读取数据时就会报错。 通常情况下，我们只需要在 RedisConfig 中统一设置好 4 个 serializer 即可。 Jackson2JsonRedisSerializer 与 GenericJackson2JsonRedisSerializer 的对比 两者都是将对象的数据序列化成 JSON 格式的字符串。 Jackson2JsonRedisSerializer 需要自己指定 ObjectMaper 或某个特定的类型。 GenericJackson2JsonRedisSerializer 是 Jackson2JsonRedisSerializer 的一个特例，默认支持所有类型。 两者序列化时，都会将原始对象的类名和包名写入 JSON 字符串中。以便反序列化时，确认要将 JSON 转成何种格式。 可用如下方式来获得通用的 Jackson2JsonRedisSerializer12345678Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = ​ new Jackson2JsonRedisSerializer(Object.class);ObjectMapper om = new ObjectMapper();om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);jackson2JsonRedisSerializer.setObjectMapper(om); Jackson2JsonRedisSerializer 与 GenericJackson2JsonRedisSerializer 生成 JSON 的对比12345# Jackson2JsonRedisSerializer 序列化的效果127.0.0.1:6379&gt; get 123&quot;[\&quot;zz.domain.User\&quot;,&#123;\&quot;id\&quot;:123,\&quot;name\&quot;:\&quot;name\&quot;&#125;]&quot;127.0.0.1:6379&gt; get userList&quot;[\&quot;java.util.LinkedList\&quot;,[[\&quot;zz.domain.User\&quot;,&#123;\&quot;id\&quot;:233,\&quot;name\&quot;:\&quot;new\&quot;&#125;],[\&quot;zz.domain.User\&quot;,&#123;\&quot;id\&quot;:233,\&quot;name\&quot;:\&quot;new\&quot;&#125;]]]&quot; 12345# GenericJackson2JsonRedisSerializer 序列化的效果127.0.0.1:6379&gt; get 123&quot;&#123;\&quot;@class\&quot;:\&quot;zz.domain.User\&quot;,\&quot;id\&quot;:123,\&quot;name\&quot;:\&quot;name\&quot;&#125;&quot;127.0.0.1:6379&gt; get userList&quot;[\&quot;java.util.LinkedList\&quot;,[&#123;\&quot;@class\&quot;:\&quot;zz.domain.User\&quot;,\&quot;id\&quot;:233,\&quot;name\&quot;:\&quot;new\&quot;&#125;,&#123;\&quot;@class\&quot;:\&quot;zz.domain.User\&quot;,\&quot;id\&quot;:233,\&quot;name\&quot;:\&quot;new\&quot;&#125;]]&quot; 如何使用使用注解来缓存函数的结果在要缓存的方法上使用注解 @Cacheable、@CachePut、@CacheEvict 分别用于缓存返回数据、更新缓存数据、删除缓存数据。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package zz.service;import lombok.extern.slf4j.Slf4j;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.CachePut;import org.springframework.cache.annotation.Cacheable;import org.springframework.stereotype.Service;import zz.domain.User;/** * UserService * * @author zz * @date 2018/5/7 */@Service@Slf4jpublic class UserService &#123; public final String DEFAULT_NAME = "def"; @Cacheable(cacheNames = "user", key = "'id_'+#userId") public User get(int userId) &#123; ​ // get from db ​ log.debug("[++] get userId=" + userId); User user = new User(); user.setId(userId); user.setName(DEFAULT_NAME); log.debug("[++] create default user=" + user); return user; &#125; @CachePut(cacheNames = "user", key = "'id_'+#user.getId()") public User update(User user) &#123; ​ // save to db ​ log.debug("[++] update user=" + user); ​ return user; &#125; @CacheEvict(cacheNames = "user", key = "'id_'+#userId") public void delete(int userId) &#123; ​ // delete from db ​ log.debug("[++] delete userId=" + userId); &#125; @CachePut(cacheNames = "user", key = "'id_'+#userId") public User updateName(int userId, String name) &#123; ​ // update to db ​ log.debug("[++] updateName userId=" + userId + ", name=" + name); User user = get(userId); user.setName(name); return user; &#125; public void innerCall(int userId) &#123; ​ log.debug("[++] innerCall"); ​ get(userId); &#125;&#125; 对函数的缓存是通过代理来实现的 ：类内部的某个函数对其他函数（即便被调用函数有 @CacheXXX 注解）的调用是不会走代理的，也就没有缓存。(比如 innerCall 调用 get 时不会使用缓存) 。 注解可以放到 Service、Dao 或 Controller 层。 @CacheXXX 会缓存函数的返回值。比如 increaseComment 会缓存更新后的 FeedCount。 当缓存中有数据时，@Cacheable 注解的函数不会执行，直接返回缓存中的数据。 @CachePut、@CacheEvit 注解的函数，无论如何都会执行。 自定义缓存如果要更细粒度地控制 Redis，可以使用 RedisTemplate、StringRedisTemplate StringRedisTemplate 是 RedisTemplate 的一个特例：key 和 value 都是 String 类型。 RedisTemplate 默认使用 JDK 对 key 和 value 进行序列化，转成字节存入 Redis。 StringRedisTemplate 的 key、value 本身就是 String，使用 StringRedisSerializer 将 String 转成字节存入 Redis。 当我们将 RedisTemplate 的 keySerializer 和 valueSerializer 都设置成了 StringRedisSerializer，则 RedisTemplate 和 StringRedisTemplate 的效果是相同的，就像下面的样例所示。 RedisTemplate 对 Redis 中各个数据结构的操作 redisTemplate.opsForValue();//操作字符串 redisTemplate.opsForHash();//操作hash redisTemplate.opsForList();//操作list redisTemplate.opsForSet();//操作set redisTemplate.opsForZSet();//操作有序set 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160package zz;import lombok.extern.slf4j.Slf4j;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import org.springframework.test.context.junit4.SpringRunner;import zz.domain.User;import zz.service.UserService;import java.util.LinkedList;import java.util.List;/** * zz.TestRedis * * @author zz * @date 2018/5/7 */@SpringBootTest@RunWith(SpringRunner.class)@Slf4jpublic class TestRedis &#123; @Autowired StringRedisTemplate stringRedisTemplate; @Autowired RedisTemplate redisTemplate; @Autowired UserService userService; @Test public void testSerializer() &#123; // 1. // 这里的 opsForValue().get() 的参数必须转成 String 类型。 // 除非在 RedisConfig 中 将 keySerializer 设置成 GenericJackson2JsonRedisSerializer 等能将其他类型转换成 String 的。 // 2. // 如果切换了 RedisConfig 中的 ValueSerializer，要先用 redis-cli 将其中的旧数据删除。 // 不同 Serializer 格式之间的转换可能存在问题。 final int ID = 123; User oldUser; oldUser = (User) redisTemplate.opsForValue().get(String.valueOf(ID)); log.debug("oldUser=" + oldUser); User user = new User(); user.setId(ID); user.setName("name"); log.debug("user=" + user); redisTemplate.opsForValue().set(String.valueOf(user.getId()), user); User newUser; newUser = (User) redisTemplate.opsForValue().get(String.valueOf(ID)); log.debug("newUser=" + newUser); Assert.assertEquals(user.getId(), newUser.getId()); Assert.assertEquals(user.getName(), newUser.getName()); List&lt;User&gt; userList = new LinkedList&lt;&gt;(); userList.add(user); user.setId(233); user.setName("new"); userList.add(user); redisTemplate.opsForValue().set("userList", userList); List&lt;User&gt; newUserList; newUserList = (List&lt;User&gt;) redisTemplate.opsForValue().get("userList"); Assert.assertEquals(userList, newUserList); &#125; @Test public void testSerizlizer2() &#123; // 保存用于恢复，以免影响其他部分 RedisSerializer oldKeySerializer = redisTemplate.getKeySerializer(); RedisSerializer oldValueSerializer = redisTemplate.getValueSerializer(); RedisSerializer redisSerializer = new StringRedisSerializer(); redisTemplate.setKeySerializer(redisSerializer); redisTemplate.setValueSerializer(redisSerializer); final String KEY = "key"; String VALUE = "value"; redisTemplate.opsForValue().set(KEY, VALUE); Assert.assertEquals(VALUE, redisTemplate.opsForValue().get(KEY)); Assert.assertEquals(VALUE, stringRedisTemplate.opsForValue().get(KEY)); VALUE = "Val2"; stringRedisTemplate.opsForValue().set(KEY, VALUE); Assert.assertEquals(VALUE, stringRedisTemplate.opsForValue().get(KEY)); Assert.assertEquals(VALUE, redisTemplate.opsForValue().get(KEY)); // 恢复原本设置 redisTemplate.setKeySerializer(oldKeySerializer); redisTemplate.setValueSerializer(oldValueSerializer); &#125; @Test public void testCache() &#123; final int USER_ID = 1; User user = userService.get(USER_ID); log.debug("user=" + user); Assert.assertEquals(userService.DEFAULT_NAME, user.getName()); // 这次会直接返回 cache user = userService.get(USER_ID); log.debug("user=" + user); // 获得修改过的 cache final String ANOTHER_NAME = "another user"; user.setName(ANOTHER_NAME); userService.update(user); user = userService.get(USER_ID); log.debug("user=" + user); Assert.assertEquals(ANOTHER_NAME, user.getName()); // 直接调用 get 会走缓存，通过 innerCall 来调用 get 不会走缓存 log.debug("------ before"); userService.get(USER_ID); log.debug("------ middle"); userService.innerCall(USER_ID); log.debug("------ after"); // 另一种修改的方式 final String NEW_NAME = "updated"; userService.updateName(USER_ID, NEW_NAME); user = userService.get(USER_ID); log.debug("user=" + user); Assert.assertEquals(NEW_NAME, user.getName()); // 删除后，cache 中的数据会被删除，name 会变成初始值 userService.delete(USER_ID); user = userService.get(USER_ID); log.debug("user=" + user); Assert.assertEquals(userService.DEFAULT_NAME, user.getName()); // 即使 cache 中没有该数据，也会执行 delete 中的逻辑 userService.delete(USER_ID); userService.delete(USER_ID); &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>旧文补发</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗讲解 HTTPS]]></title>
    <url>%2F2018%2F04%2F28%2Fsimple-intro-to-https%2F</url>
    <content type="text"><![CDATA[为什么要用 HTTPSHTTP 是明文传输，任何人都能窃听到，甚至篡改。 HTTPS 可以有效防止窃听和篡改，能极大提高网站的安全性。 HTTPS 如何保障安全性加密传输数据HTTPS 会先将数据进行加密再传输，在网络中传输的时候任何人都只能捕获到加密后的数据。而只有拥有相应的秘钥才能解开数据。 那这里就有了新的问题：数据要怎么加密，用哪种加密方法来加密，客户端和服务端怎么协商确定秘钥，同时保证秘钥不被第三方所知道。 对称加密与非对称加密先简单介绍两种加密的方式：对称加密和非对称加密。 顾名思义，对称加密就是加密和解密时使用的是相同的秘钥，优点是速度快。缺点是任意两个通信的实体之间都要维护他们彼此间通信的秘钥，而维护这么多的秘钥的成本太大了。 非对称加密就是加密和解密使用的是不同的秘钥，分别称之为公钥和私钥。公钥可以公开出来让所有人知道；私钥必须保存好，不能让其他人知道。非对称加密的特点是用公钥加密的数据只能用私钥解密，用私钥加密的数据只能用公钥解密。缺点是速度慢。 于是，我们可以这样操作：​123456789客户端随机生成一个秘钥 A，使用服务端的公钥加密后发送给服务端。服务端收到后，用自己的私钥进行解密获得 A。服务端告诉客户端自己已经获得了 A。这样客户端和服务端就都得到了一个秘钥 A，且不为其他人所知。秘钥 A 只在本次通信过程中有效。随后客户端每次发送数据前，都用秘钥 A 进行对称加密，服务端收到后都用秘钥 A 进行解密。服务端发送数据给客户端时，也采用类似的操作。​ 通过这样的操作，我们利用非对称加密来达到协商和确定好对称加密的秘钥 A，同时又利用了对称加密速度快的特点。 实际上 HTTPS 协商秘钥 A 的过程会比这个更复杂。但本质都是利用非对称加密来达到协商的目的。 这里实际上就有了一个新的问题：客户端怎么拿到服务端的公钥，同时确保这就是服务端的公钥而不是其他人伪造的。 HTTPS 证书当我们访问一个 HTTPS 的网站时，服务端会下发一个 HTTPS 证书给我们。证书里面就包含了服务端的公钥，同时还有其他信息：证书所属的域名、颁发的机构、何时生效、何时过期等。 那现在问题就是我们如何确认一个证书是不是有效的，而且是不是我们访问的服务端发给我们的。 这里就牵扯到了 HTTPS 证书的生成。 简单说明一下 CA（证书颁发机构），CA 专门管理证书的申请和颁发。 申请证书的过程如下：​1234567891011121314151617服务端向 CA 申请自己的 HTTPS 证书，CA 审核通过后，就会将服务端的域名、公钥、证书的有效期等信息写到证书里。同时 CA 会对证书里的信息做一个哈希获得一个哈希值，用自己的秘钥对这个哈希值进行加密获得一个加密串，并把加密串也写到证书里。这一过程称之为签名。（签名就是证明这证书的确是 CA 发的，CA 为证书进行背书。）现在，当我们访问网站后收到一个证书时，首先用 CA 的公钥对加密串进行解密，得到加密前的哈希值。再对证书本身的数据做一个哈希，如果这两个哈希值是一致的说明证书有效。同时还要注意证书是否在有效期内。通过以上校验，我们就可以认为这的确是我们期望的服务端下发的证书。假设有人伪造了证书，假装自己是服务端，由于他没有 CA 的秘钥，也就无法构造出与伪造数据吻合的加密串。我们只要用 CA 的公钥对加密串一解密，发现哈希值不一致，就可以认定这是伪造的。​ 这里又牵出了新的问题：我们怎么拿到 CA 的公钥。 全球只有为数不多的几个顶级 CA 有资格进行 HTTPS 证书的颁发。 所以操作系统和浏览器会预装这些 CA 的证书（包含了 CA 的公钥）。也就省去我们获取 CA 公钥的步骤和获取过程可能存在的伪造。 这里也可以看出 CA 证书是多么重要。如果我们电脑中安装了恶意的 CA 证书，而这个 CA 又故意或无意签发了大量恶意服务端的证书，那我们即便使用了 HTTPS 也无法保证安全通信。 客户端证书大部分时候，我们都是从服务端拿数据，所以主要保证服务端是我们要访问的，也就是服务端要配置 HTTPS 证书。 如果为了让服务端确认客户端的确是谁，在大多数情况下使用“账号+密码”或“手机号+短信验证码”已经足够了。 为每个客户端都配置 HTTPS 证书，一个是申请证书本身需要费用；一个是申请的门槛较高，不是每个用户都能做到。 也因此，只要服务端配置了 HTTPS 证书，在大多数情况下已经足够安全了。 但是，对于某些对安全性要求极高的网站来说，他们也会要求客户端要安装 HTTPS 证书。 比如银行网上转账就是一个十分敏感的操作。通常在我们申请银行卡的时候会得到一个 U 盾。 U 盾里面实际上也是一个 HTTPS 证书，用于证明“我就是我”。 只是这个证书是由银行自己颁发的。（实际上要像 CA 那样发布证书是很容易的，但是只有少数权威的 CA 才被操作系统和浏览器所认可。） 当我们要进行网上转账的时候，就必须把 U 盾插入到电脑上，访问银行的相关网站时，就会把 U 盾中的证书带上去。 银行的服务端在收到我们的证书，就用自己的私钥进行解密，也就能确认我们的身份了。 Ref深入浅出 HTTPS]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>旧文补发</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 编译与链接]]></title>
    <url>%2F2017%2F08%2F27%2Flinux-compile-link%2F</url>
    <content type="text"><![CDATA[Linux 下 C/C++ 代码编译链接生成可执行程序的过程，主要包括如下几个步骤。 预处理12#只进行预处理并把预处理结果输出g++ -E source.cpp -o source.i 预处理过程主要处理源代码文件中以 # 开始的预编译指令，包括如下规则。 将所有的 #define 删除，并且展开所有的宏定义。 处理所有的条件预编译指令，包括 #if、 #ifdef、 #ifndef、 #elif、 #else、 #endif 等。 处理 #include 预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件，也会同样被插入。 过滤所有的注释中的内容，包括 // 和 /* */。 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。 保留所有的 #pragma 编译器指令，因为编译器需要使用它们。 编译12#输出编译后的汇编代码文件g++ -S source.i -o source.s 编译过程就是把预处理完的文件进行如下的一系列操作后产生相应的汇编代码文件。这个过程往往是整个程序构建的核心部分，也是最复杂的部分之一。 词法分析 语法分析 语义分析 源代码优化 代码生成 目标代码优化这里不展开一一赘述。 通过如下命令，我们可以直接从源文件得到目标文件/中间代码文件，如 .o 文件。 12#只编译不链接g++ -c source.cpp 链接各个源代码模块独立地编译成目标文件，链接就是把这些目标文件和库链接形成可执行文件的过程。这里的“库”指的是：一组目标文件的包，也就是将一些常用的代码编译成目标文件后打包存放，便于使用。链接分为静态链接和动态链接。 静态链接对函数库的链接是放在编译时期完成的是静态链接。静态库文件命名格式为：libNAME.a 。有如下 5 个文件： 12345//add.h#ifndef _ADD_H_#define _ADD_H_int add(int a, int b);#endif 123456//add.cpp#include "add.h"int add(int a, int b)&#123; return a + b;&#125; 12345//sub.h#ifndef _SUB_H_#define _SUB_H_int sub(int a, int b);#endif 123456//sub.cpp#include "sub.h"int sub(int a, int b)&#123; return a - b;&#125; 1234567891011//main.cpp#include "add.h"#include "sub.h"#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "1+2=" &lt;&lt; add(1, 2) &lt;&lt; endl; cout &lt;&lt; "1-2=" &lt;&lt; sub(1, 2) &lt;&lt; endl; return 0;&#125; 生成静态库并链接形成可执行文件的过程如下：将 add.cpp 和 sub.cpp 编译成 .o 文件12g++ -c add.cppg++ -c sub.cpp 由 .o 文件创建静态库1ar cr libmymath.a sub.o add.o 链接静态库并生成可执行文件 main123# -L 额外指定库搜索路径# -l 额外指定链接的库g++ -o main main.cpp -L. -lmymath ar 命令用于创建和维护库文件。 c 选项：不管是否已存在，创建一个库。 r 选项： 在库中插入或替换模块。 tv 选项： 显示库中有哪些目标文件，显示文件名、时间、大小等详细信息。 运行1./main 动态链接对库函数的链接载入推迟到程序运行时期就是动态链接。动态库文件命名格式为：libNAME.so 。同样以上面的 5 个文件为例。 如果你边跟着本文顺序，边在动手实践的话，此时请暂时将静态库文件 libmymath.a 删除或重命名成其他名字。减少干扰。 生成动态库并链接形成可执行文件的过程如下：生成动态库1234567# 1.g++ -fPIC -o add.o -c add.cppg++ -fPIC -o sub.o -c sub.cppg++ -shared -o libmymath.so add.o sub.o# 或者# 2.g++ -fPIC -shared -o libmymath.so add.cpp sub.cpp -fPIC 编译为位置独立的代码。 生成目标文件1g++ -o main main.cpp -L. -lmymath 运行1./main CentOS 等 Linux 系统下直接运行会报错./main: error while loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory 使用 ldd 命令来查看目标文件shell ldd main shell linux-vdso.so.1 =&gt; (0x00007ffefc135000) libmymath.so =&gt; not found libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007ff6d629e000) libm.so.6 =&gt; /lib64/libm.so.6 (0x00007ff6d5f9c000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007ff6d5d86000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007ff6d59c4000) /lib64/ld-linux-x86-64.so.2 (0x00007ff6d65af000) 这是因为系统运行 main 时，会按照如下顺序搜索动态库： 编译目标代码时指定的动态库搜索路径 环境变量 LD_LIBRARY_PATH 指定的动态库搜索路径 配置文件 /etc/ld.so.conf 中指定的动态库搜索路径 默认的动态库搜索路径 /lib 默认的动态库搜索路径 /usr/lib也就找不到我们生成的 libmymath.so 。 相应地有以下几种方法可以告诉系统如何找到我们需要的动态库。 编译时增加 -Wl,-rpath来指定额外的动态库搜索路径。当指定多个动态库搜索路径时，路径之间用冒号 ： 分隔。shell g++ -o main main.cpp -L. -lmymath -Wl,-rpath=. 修改环境变量 LD_LIBRARY_PATHshell export LD_LIBRARY_PATH=/PATH_TO_LIB:$LD_LIBRARY_PATH 修改配置文件 /etc/ld.so.conf sudo vi /etc/ld.so.conf将动态库所在路径添加到 ld.so.conf 中PATH_TO_LIB使修改生效sudo ldconfig 将我们的库添加到默认路径中 1234567sudo cp libmymath.so /usr/lib# 或sudo cp libmymath.so /lib# 如果复制后还是找不到动态库文件，可执行下述命令，详情请看 参考里的 ldconfig 详解# sudo ldconfig MacOS 下系统会自动在目标文件所在路径寻找动态库文件，所以可以直接运行不会报错。Mac 下没有 ldd命令， 可通过 otool -L来查看目标文件的依赖。 1otool -L main 1234main: libmymath_one.so (compatibility version 0.0.0, current version 0.0.0) /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.5.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.60.2) 动态库和静态库同名问题以上述文件为例，我们在同一目录中分别执行命令生成动态库和静态库，即 libmymath.so和 libmymath.a。此时执行 g++ -o main main.cpp -L. -lmymath，然后运行目标文件 ./main，会看到./main: error while loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory也就是说编译器优先采用了动态链接来生成目标文件：首先到path目录下搜索 libXXX.so动态库文件，如果没有找到，才会搜索 libXXX.a静态库文件。 动态库与静态库的对比 动态库 有利于进程间资源共享，减少资源占用。 方便升级。只要接口不变，程序无需重新编译。 链接载入完全由程序员在程序代码中控制。 静态库 执行速度快。 编译后静态库已打包在目标文件中，减少了依赖。 g++ 与 gcc 的对比 g++ 和 g++ 都可以编译 C++ 代码。在编译阶段 g++ 会自动调用 gcc ，两者是等价的。 后缀为 .c 的代码， gcc 把它当作是 C 程序， 而 g++ 当作 C++ 程序；后缀为 .cpp 的，两者都会将其当作 C++ 程序。 链接可以用 g++ 或 gcc-lstdc++ 。 gcc 命令不能自动和 C++ 程序使用的库链接。 __cplusplus宏标志着编译器会把代码按 C 还是 C++ 语法来解释。对于 g++ 来说，该宏都会定义；对于 gcc 来说，该宏是否定义取决于文件后缀。 以下述 .c 文件为例。 123456789101112#source.c#include &lt;stdio.h&gt;int main()&#123;#ifdef __cplusplus printf("define __cplusplus\n");#else printf("undefine __cplusplus\n");#endif return 0;&#125; 使用 gcc 编译生成目标文件并运行 12gcc -o source source.c./source 会看到 1undefine __cplusplus 将后缀改成 .cpp ，重新编译运行 123mv source.c source.cppgcc -o source source.cpp./source 会看到 1define __cplusplus g++ 和 gcc 对采用了 extern &quot;C&quot;的 symbol 都会以 C 的方式来命名。 以下述文件为例 12345// me.h#ifndef _ME_H_#define _ME_H_extern "C" void CppPrintf(void);#endif 12345678// me.cpp#include &lt;iostream&gt;#include "me.h"using namespace std;void CppPrintf(void)&#123; cout &lt;&lt; "Hello" &lt;&lt; endl;&#125; 1234567// test.cpp#include "me.h"int main()&#123; CppPrintf(); return 0;&#125; 执行下述命令 12345gcc -S me.cpp# 或者# g++ -S me.cpp# 效果相同less me.s 可以看到 1call CppPrintf 将 me.h 中的 extern &quot;C&quot;删除后，执行下述命令 12345gcc -S me.cpp# 或者# g++ -S me.cpp# 效果相同less me.s 可以看到 1call _Z9CppPrintfv 参考 《后台开发：核心技术与应用实践》第 4 章 编译 ldconfig 命令]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>旧文补发</tag>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些 iOS 编译错误的原因及其解决方法]]></title>
    <url>%2F2017%2F08%2F26%2Fios-compile%2F</url>
    <content type="text"><![CDATA[最近工作涉及到 iOS，使用过程中经常遇到不少错误，特此记录，以备查询。 所用环境为 Max OS 10.12.6 Xcode 8.3.3 iOS 10.3.3 0.出现错误后，在红色错误信息处，“右键 - Reveal in log - Detail Message” 会看到详细的出错信息，一般能从这里看到具体的问题是什么，然后采取相应的措施。 简单来说，就是两步“Google error message”、“Copy from StackOverFlow” 。 有时候一种现象，背后会有多种原因，于是就需要多试几种方法。总会解决的:). 由于本人对 iOS 完全是一知半解，如有不对之处，还望指出，不吝感激。 1. Applications are expected to have a root view controller at the end of application launchhttps://stackoverflow.com/questions/7520971/applications-are-expected-to-have-a-root-view-controller-at-the-end-of-applicati/32680220#32680220 iOS 从某个版本之后每个 window都要设置一个 RootViewController。否则在运行时便会挂掉。 检查你的 AppDelegate.m 文件（或者是 XXXXAppDelegate.m 文件）的 didFinishLaunchingWithOptions 函数。如果函数中是如下形式： [window addSubview:[someController view]];则将其改为 [self.window setRootViewController:someController];如果修改之后，仍报同样的错误。说明你程序中有不止一个 window ，而你并没有为每个 window 都设置了 RootViewController 。全部设置相应的 RootViewController 后即可解决。 需要注意的是 iOS 会默认根据 xib/storyboard 生成一个 window （本人对 iOS 并不是很熟，如果这里说法有误，欢迎指正）。所以有时候，你只有一个 window ，并且设置了 RootViewController 后还报错，则需要将类似如下代码的创建 window 的代码删除。 1self.window = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]] autorelease]; 2. 模拟器上正常运行，真机测试时报错 &quot;_WebPGetFeaturesInternal&quot;, referenced from: &quot;_png_get_io_ptr&quot;, referenced from: &quot;_TIFFGetField&quot;, referenced from: &quot;_jpeg_read_header&quot;, referenced from: &quot;_TIFFClientOpen&quot;, referenced from: &quot;_FT_Get_Glyph&quot;, referenced from: “右键 - Reveal in log - Detail Message” ，可看到 Undefined symbols for architecture arm64 这种情况通常是程序在 Build 的过程中没有将用到的所有 Library 链接进去。 通过“选中项目 - TARGETS - Build Phases - Link Binary With Libraries” ，并根据上面报错的名字，将相应的 Library 添加进去即可。 我这里是因为用了 cosos2d ，所以将 /PATH_TO_COSOS2D/cocos2d/external/XXX_MODULE/prebuilt/ios/libXXX[_arm64].a 包含进去即可。 将库添加后，如果还报错，则需在“项目 - Build Setting - Library Search Paths” 中添加“刚才添加的库”的目录。（在后面选择 recursive 可使编译器搜索指定目录及其子目录。) 3. unknow type name ‘namespace’等诸如 C++ 中的语法，编译时报错。通常报错的文件是 .h 文件，而包含该文件的是 .h 或 .m 文件。将 .m 后缀修改成 .mm 后缀，编译器便会将该文件当做 Objective-C++ 文件来编译。 或者选中文件后，在右侧的 “Identity and Type - Type” 中选择 “Objective-C++ File” 也可达到同样的效果。 4. library not found for -lcrt1.3.1.ohttp://blog.csdn.net/skylin19840101/article/details/56008803 crt1.3.1.o is a library that was included in older iOSes (and thus, their SDKs) but is no longer present in newer SDKs. However, when the project’s Deployment Target is set to an older ios (&lt;6.0, as @Sandy has found), Xcode still tries linking against it.在 iOS6 以及更高的版本中，crt1.3.1.o 已经没有了。 修改支持的最低 iOS 系统版本在 “项目 - TARGETS - General -&gt; Deployment Info -&gt; Deployment Target” 中，把 5.0(及以下的)改为 6.0(及以上的) 5. Use of undeclared identifier ‘glDeleteTextures’https://stackoverflow.com/questions/24024764/errors-showing-for-oes-opengl-statements-in-xcode-6-for-ios8添加如下代码 #import &lt;OpenGLES/ES2/glext.h&gt; 6. ‘release’ is unavailable: not available in automatic reference counting modehttps://stackoverflow.com/questions/22996437/release-is-unavailable-not-available-in-automatic-reference-counting-mode Xcode 设置中开启了 ARC ， 但是代码仍然进行了内存释放等操作。要么关闭 ARC ， 要么去掉代码中的释放内存相关的代码。 7. clang:error: -fembed-bitcode is not supported on versions of iOS prior to 6.0或者 12345/PATH_TO_COSOS2D/cocos2d/external/freetype2/prebuilt/ios/libfreetype.a(ftbase.o)'does not contain bitcode.You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE),obtain an updated library from the vendor,or disable bitcode for this target. for architecture armv7 这都是因为新的 iOS 不支持 bitcode 选项。将 “项目 - TARGETS - Build Setting - Enable Bitcode” ， 改为 no 即可。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>XCode</tag>
        <tag>iOS</tag>
        <tag>旧文补发</tag>
      </tags>
  </entry>
</search>
