<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《后台开发：核心技术与应用实践》第 4 章 编译 之 4.2 makefile]]></title>
    <url>%2Fblog%2F2017%2F08%2F27%2Fmakefile%2F</url>
    <content type="text"><![CDATA[概述makefile 文件是 Linux 下程序员告诉编译器如何按照一定的步骤，编译链接出最终目标程序的描述文件。 makefile 文件中也可以包含 shell 命令。 make 是 Linux 中解释并执行 makefile 中指令的命令行工具。 通过 makefile 文件我们可以更好地管理项目中各文件间的依赖关系，方便我们进行编译。 下面将简述 makefile 的一些编写规则。 关于编译链接的一些概念参见 《后台开发：核心技术与应用实践》第 4 章 编译 之 4.1 编译与链接。 To be done.]]></content>
      <categories>
        <category>码农的自我修养</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《后台开发：核心技术与应用实践》第 4 章 编译 之 4.1 编译与链接]]></title>
    <url>%2Fblog%2F2017%2F08%2F27%2Flinux-compile-link%2F</url>
    <content type="text"><![CDATA[Linux 下 C/C++ 代码编译链接生成可执行程序的过程，主要包括如下几个步骤。 预处理12#只进行预处理并把预处理结果输出g++ -E source.cpp -o source.i 预处理过程主要处理源代码文件中以 # 开始的预编译指令，包括如下规则。 将所有的 #define 删除，并且展开所有的宏定义。 处理所有的条件预编译指令，包括 #if、 #ifdef、 #ifndef、 #elif、 #else、 #endif 等。 处理 #include 预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件，也会同样被插入。 过滤所有的注释中的内容，包括 // 和 /* */。 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。 保留所有的 #pragma 编译器指令，因为编译器需要使用它们。 编译12#输出编译后的汇编代码文件g++ -S source.i -o source.s 编译过程就是把预处理完的文件进行如下的一系列操作后产生相应的汇编代码文件。这个过程往往是整个程序构建的核心部分，也是最复杂的部分之一。 词法分析 语法分析 语义分析 源代码优化 代码生成 目标代码优化这里不展开一一赘述。 通过如下命令，我们可以直接从源文件得到目标文件/中间代码文件，如 .o 文件。12#只编译不链接g++ -c source.cpp 链接各个源代码模块独立地编译成目标文件，链接就是把这些目标文件和库链接形成可执行文件的过程。这里的“库”指的是：一组目标文件的包，也就是将一些常用的代码编译成目标文件后打包存放，便于使用。链接分为静态链接和动态链接。 静态链接对函数库的链接是放在编译时期完成的是静态链接。静态库文件命名格式为：libNAME.a 。有如下 5 个文件：12345//add.h#ifndef _ADD_H_#define _ADD_H_int add(int a, int b);#endif 123456//add.cpp#include "add.h"int add(int a, int b)&#123; return a + b;&#125; 12345//sub.h#ifndef _SUB_H_#define _SUB_H_int sub(int a, int b);#endif 123456//sub.cpp#include "sub.h"int sub(int a, int b)&#123; return a - b;&#125; 1234567891011//main.cpp#include "add.h"#include "sub.h"#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; "1+2=" &lt;&lt; add(1, 2) &lt;&lt; endl; cout &lt;&lt; "1-2=" &lt;&lt; sub(1, 2) &lt;&lt; endl; return 0;&#125; 生成静态库并链接形成可执行文件的过程如下：将 add.cpp 和 sub.cpp 编译成 .o 文件12g++ -c add.cppg++ -c sub.cpp 由 .o 文件创建静态库1ar cr libmymath.a sub.o add.o 链接静态库并生成可执行文件 main123# -L 额外指定库搜索路径# -l 额外指定链接的库g++ -o main main.cpp -L. -lmymath ar 命令用于创建和维护库文件。 c 选项：不管是否已存在，创建一个库。 r 选项： 在库中插入或替换模块。 tv 选项： 显示库中有哪些目标文件，显示文件名、时间、大小等详细信息。 运行1./main 动态链接对库函数的链接载入推迟到程序运行时期就是动态链接。动态库文件命名格式为：libNAME.so 。同样以上面的 5 个文件为例。 如果你边跟着本文顺序，边在动手实践的话，此时请暂时将静态库文件 libmymath.a 删除或重命名成其他名字。减少干扰。 生成动态库并链接形成可执行文件的过程如下：生成动态库1234567# 1.g++ -fPIC -o add.o -c add.cppg++ -fPIC -o sub.o -c sub.cppg++ -shared -o libmymath.so add.o sub.o# 或者# 2.g++ -fPIC -shared -o libmymath.so add.cpp sub.cpp -fPIC 编译为位置独立的代码。 生成目标文件1g++ -o main main.cpp -L. -lmymath 运行1./main CentOS 等 Linux 系统下 直接运行会报错 1./main: error while loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory 使用 ldd 命令来查看目标文件 1ldd main 1234567linux-vdso.so.1 =&gt; (0x00007ffefc135000)libmymath.so =&gt; not foundlibstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007ff6d629e000)libm.so.6 =&gt; /lib64/libm.so.6 (0x00007ff6d5f9c000)libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007ff6d5d86000)libc.so.6 =&gt; /lib64/libc.so.6 (0x00007ff6d59c4000)/lib64/ld-linux-x86-64.so.2 (0x00007ff6d65af000) 这是因为系统运行 main 时，会按照如下顺序搜索动态库： 编译目标代码时指定的动态库搜索路径 环境变量 LD_LIBRARY_PATH 指定的动态库搜索路径 配置文件 /etc/ld.so.conf 中指定的动态库搜索路径 默认的动态库搜索路径 /lib 默认的动态库搜索路径 /usr/lib也就找不到我们生成的 libmymath.so 。 相应地有以下几种方法可以告诉系统如何找到我们需要的动态库。 编译时增加 -Wl,-rpath 来指定额外的动态库搜索路径。当指定多个动态库搜索路径时，路径之间用冒号 ： 分隔。 1g++ -o main main.cpp -L. -lmymath -Wl,-rpath=. 修改环境变量 LD_LIBRARY_PATH 1export LD_LIBRARY_PATH=/PATH_TO_LIB:$LD_LIBRARY_PATH 修改配置文件 /etc/ld.so.conf 1sudo vi /etc/ld.so.conf 将动态库所在路径添加到 ld.so.conf 中 1PATH_TO_LIB 使修改生效 1sudo ldconfig 将我们的库添加到默认路径中 123456sudo cp libmymath.so /usr/lib# 或sudo cp libmymath.so /lib# 如果复制后还是找不到动态库文件，可执行下述命令，详情请看 参考里的 ldconfig 详解# sudo ldconfig MacOS 下系统会自动在目标文件所在路径寻找动态库文件，所以可以直接运行不会报错。Mac 下没有 ldd 命令， 可通过 otool -L 来查看目标文件的依赖。1otool -L main 1234main: libmymath_one.so (compatibility version 0.0.0, current version 0.0.0) /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.5.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.60.2) 动态库和静态库同名问题以上述文件为例，我们在同一目录中分别执行命令生成动态库和静态库，即 libmymath.so 和 libmymath.a。此时执行 g++ -o main main.cpp -L. -lmymath，然后运行目标文件 ./main，会看到./main: error while loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory也就是说编译器优先采用了动态链接来生成目标文件：首先到 path 目录下搜索 libXXX.so 动态库文件，如果没有找到，才会搜索 libXXX.a 静态库文件。 动态库与静态库的对比 动态库 有利于进程间资源共享，减少资源占用。 方便升级。只要接口不变，程序无需重新编译。 链接载入完全由程序员在程序代码中控制。 静态库 执行速度快。 编译后静态库已打包在目标文件中，减少了依赖。 g++ 与 gcc 的对比g++ 和 g++ 都可以编译 C++ 代码。在编译阶段 g++ 会自动调用 gcc ，两者是等价的。后缀为 .c 的代码， gcc 把它当作是 C 程序， 而 g++ 当作 C++ 程序；后缀为 .cpp 的，两者都会将其当作 C++ 程序。链接可以用 g++ 或 gcc-lstdc++ 。 gcc 命令不能自动和 C++ 程序使用的库链接。__cplusplus 宏标志着编译器会把代码按 C 还是 C++ 语法来解释。对于 g++ 来说，该宏都会定义；对于 gcc 来说，该宏是否定义取决于文件后缀。以下述 .c 文件为例。123456789101112#source.c#include &lt;stdio.h&gt;int main()&#123;#ifdef __cplusplus printf("define __cplusplus\n");#else printf("undefine __cplusplus\n");#endif return 0;&#125; 使用 gcc 编译生成目标文件并运行12gcc -o source source.c./source 会看到1undefine __cplusplus 将后缀改成 .cpp ，重新编译运行123mv source.c source.cppgcc -o source source.cpp./source 会看到1define __cplusplus g++ 和 gcc 对采用了 extern &quot;C&quot; 的 symbol 都会以 C 的方式来命名。以下述文件为例 12345// me.h#ifndef _ME_H_#define _ME_H_extern "C" void CppPrintf(void);#endif 12345678// me.cpp#include &lt;iostream&gt;#include "me.h"using namespace std;void CppPrintf(void)&#123; cout &lt;&lt; "Hello" &lt;&lt; endl;&#125; 1234567// test.cpp#include "me.h"int main()&#123; CppPrintf(); return 0;&#125; 执行下述命令12345gcc -S me.cpp# 或者# g++ -S me.cpp# 效果相同less me.s 可以看到1call CppPrintf 将 me.h 中的 extern &quot;C&quot; 删除后，执行下述命令12345gcc -S me.cpp# 或者# g++ -S me.cpp# 效果相同less me.s 可以看到1call _Z9CppPrintfv 参考ldconfig 命令]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Xcode iOS 一些编译错误的原因及其解决方法]]></title>
    <url>%2Fblog%2F2017%2F08%2F26%2Fapple-complier-error%2F</url>
    <content type="text"><![CDATA[最近在做一些 iOS 方面的学习。过程中经常遇到不少错误，特此记录，以备查询。 所用环境为 Max OS 10.12.6 Xcode 8.3.3 iOS 10.3.3 0.出现错误后，在红色错误信息处，“右键 - Reveal in log - Detail Message” 会看到详细的出错信息，一般能从这里看到具体的问题是什么，然后采取相应的措施。 简单来说，就是两步“Google error message”、“Copy from StackOverFlow” 。 有时候一种现象，背后会有多种原因，于是就需要多试几种方法。总会解决的:). 由于本人对 iOS 完全是一知半解，如有不对之处，还望指出，不吝感激。 1. Applications are expected to have a root view controller at the end of application launchhttps://stackoverflow.com/questions/7520971/applications-are-expected-to-have-a-root-view-controller-at-the-end-of-applicati/32680220#32680220 iOS 从某个版本之后每个window都要设置一个RootViewController。否则在运行时便会挂掉。 检查你的 “AppDelegate.m” 文件（或者是 “XXXXAppDelegate.m” 文件）的 didFinishLaunchingWithOptions 函数。 如果函数中是如下形式：1[window addSubview:[someController view]]; 则将其改为1[self.window setRootViewController:someController]; 如果修改之后，仍报同样的错误。说明你程序中有不止一个 window ，而你并没有为每个 window 都设置了 RootViewController 。全部设置相应的 RootViewController 后即可解决。 需要注意的是 iOS 会默认根据 xib/storyboard 生成一个 window （本人对 iOS 并不是很熟，如果这里说法有误，欢迎指正）。所以有时候，你只有一个 window ，并且设置了 RootViewController 后还报错，则需要将类似如下代码的创建 window 的代码删除。1self.window = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]] autorelease]; 2. 模拟器上正常运行，真机测试时报错 &quot;_WebPGetFeaturesInternal&quot;, referenced from: &quot;_png_get_io_ptr&quot;, referenced from: &quot;_TIFFGetField&quot;, referenced from: &quot;_jpeg_read_header&quot;, referenced from: &quot;_TIFFClientOpen&quot;, referenced from: &quot;_FT_Get_Glyph&quot;, referenced from: “右键 - Reveal in log - Detail Message” ，可看到 Undefined symbols for architecture arm64 这种情况通常是程序在 Build 的过程中没有将用到的所有 Library 链接进去。 通过“选中项目 - TARGETS - Build Phases - Link Binary With Libraries” ，并根据上面报错的名字，将相应的 Library 添加进去即可。 我这里是因为用了 cosos2d ，所以将1“/PATH_TO_COSOS2D/cocos2d/external/XXX_MODULE/prebuilt/ios/libXXX[_arm64].a” 包含进去即可。 将库添加后，如果还报错，则需在“项目 - Build Setting - Library Search Paths” 中添加“刚才添加的库”的目录。（在后面选择 recursive 可使编译器搜索指定目录及其子目录。) 3. unknow type name ‘namespace’等诸如 C++ 中的语法，编译时报错。通常报错的文件是 .h 文件，而包含该文件的是 .h 或 .m 文件。将 .m 后缀修改成 .mm 后缀，编译器便会将该文件当做 Objective-C++ 文件来编译。 或者选中文件后，在右侧的 “Identity and Type - Type” 中选择 “Objective-C++ File” 也可达到同样的效果。 4. library not found for -lcrt1.3.1.ohttp://blog.csdn.net/skylin19840101/article/details/56008803 crt1.3.1.o is a library that was included in older iOSes (and thus, their SDKs) but is no longer present in newer SDKs. However, when the project’s Deployment Target is set to an older ios (&lt;6.0, as @Sandy has found), Xcode still tries linking against it. 在iOS6以及更高的版本中，crt1.3.1.o已经没有了。 修改支持的最低iOS系统版本在 “项目 - TARGETS - General -&gt; Deployment Info -&gt; Deployment Target” 中，把5.0(及以下的)改为6.0(及以上的) 5. Use of undeclared identifier ‘glDeleteTextures’https://stackoverflow.com/questions/24024764/errors-showing-for-oes-opengl-statements-in-xcode-6-for-ios8添加如下代码1#import &lt;OpenGLES/ES2/glext.h&gt; 6. ‘release’ is unavailable: not available in automatic reference counting modehttps://stackoverflow.com/questions/22996437/release-is-unavailable-not-available-in-automatic-reference-counting-mode xcode 设置中开启了 ARC ， 但是代码仍然进行了内存释放等操作。要么关闭 ARC ， 要么去掉代码中的释放内存相关的代码。 7. clang:error: -fembed-bitcode is not supported on versions of iOS prior to 6.0或者12345/PATH_TO_COSOS2D/cocos2d/external/freetype2/prebuilt/ios/libfreetype.a(ftbase.o)'does not contain bitcode.You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE),obtain an updated library from the vendor,or disable bitcode for this target. for architecture armv7 这都是因为新的 iOS 不支持 bitcode 选项。将 “项目 - TARGETS - Build Setting - Enable Bitcode” ， 改为 no 即可。]]></content>
      <categories>
        <category>码农的自我修养</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《编写可读代码的艺术》第 15 章 设计并改进 "分钟/小时计数器"]]></title>
    <url>%2Fblog%2F2017%2F08%2F09%2F%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF-MinuteHourCounter%2F</url>
    <content type="text"><![CDATA[一个 MinuteHourCounter （分钟/小时计数器），用于统计过去一段时间内某事发生的频次。下面是《编写可读代码的艺术》中的几种实现方式。 一个幼稚的方案 每当事件发生时，将其（时间，频次）的元祖放入列表中。每次统计时，计算相应事件段内的频次之和。 123456789101112131415161718192021222324252627282930313233class MinuterHourCounter &#123; struct Event &#123; Event(int count, time_t time) : count(count), time(time) &#123;&#125; int count; time_t time; &#125;; list&lt;Event&gt; events;public: void Add(int count) &#123; events.push_back(Event(count, time(0))); &#125; int MinuteCount() &#123; int count = 0; const time_t now_secs = time(0); for (list&lt;Event&gt;::reverse_iterator i = events.rbegin(); i != events.rend() &amp;&amp; i-&gt;time &gt; now_secs - 60; ++i) &#123; count += i-&gt;count; &#125; return count; &#125; int HourCount() &#123; int count = 0; const time_t now_secs = time(0); for (list&lt;Event&gt;::reverse_iterator i = events.rbegin(); i != events.rend() &amp;&amp; i-&gt;time &gt; now_secs - 3600; ++i) &#123; count += i-&gt;count; &#125; return count; &#125;&#125;; 一个更易读的版本 抽离了 MinuteCount 和 HourCount 相同的部分 迭代器变量使用了更常用的名字 将条件判断从循环中抽取出来 123456789101112131415161718192021222324252627282930313233class MinuterHourCounter &#123; struct Event &#123; Event(int count, time_t time) : count(count), time(time) &#123;&#125; int count; time_t time; &#125;; list&lt;Event&gt; events; int CountSince(time_t cutoff) &#123; int count = 0; for (list&lt;Event&gt;::reverse_iterator rit = events.rbegin(); rit != events.rend(); ++rit) &#123; if (rit-&gt;time &lt;= cutoff) &#123; break; &#125; count += rit-&gt;count; &#125; return count; &#125;public: void Add(int count) &#123; events.push_back(Event(count, time(0))); &#125; int MinuteCount() &#123; return CountSince(time(0) - 60); &#125; int HourCount() &#123; return CountSince(time(0) - 3600); &#125;&#125;; 性能问题 随着程序的不断运行，列表会占据大量的内存，而且其中大部分是无用的过期数据 MinuteCount() 和 HourCount() 的时间复杂度为 O(n) 传送带设计方案 删除不再需要的数据 更新事先算好的 minute_count 和 hour_count 变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MinuteHourCounter &#123; list&lt;Event&gt; minute_events; list&lt;Event&gt; hour_events; // only contains elements NOT in minute_events int minute_count; int hour_count; void ShiftOldEvents(time_t now_secs) &#123; const int minute_ago = now_secs - 60; const int hour_ago = now_secs - 3600; while (!minute_events.empty() &amp;&amp; minute_events.front().time &lt;= minute_ago) &#123; hour_events.push_back(minute_events.front()); minute_count -= minute_events.front().count; minute_events.pop_front(); &#125; while (!hour_events.empty() &amp;&amp; hour_events.front().time &lt;= hour_ago) &#123; hour_count -= hour_events.front().count; hour_events.pop_front(); &#125; &#125;public: void Add(int count) &#123; const time_t now_secs = time(0); ShiftOldEvents(now_secs); minute_events.push_back(Event(count, now_secs)); minute_count += count; hour_count += count; &#125; int MinuteCount() &#123; ShiftOldEvents(time(0)); return minute_count; &#125; int HourCount() &#123; ShiftOldEvents(time(0)); return hour_count; &#125;&#125;; 存在的问题 设计不灵活 内纯占用大 时间桶设计方案 把过去一段时间内发生的事件按照时间点装到桶里，该桶的值即为该时间上事件发生的频次 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class ConveyorQueue &#123; queue&lt;int&gt; q; int max_items; int total_sum;public: ConveyorQueue(int max_items) : max_items(max_items), total_sum(0) &#123; &#125; void AddToBack(int count) &#123; if (q.empty()) Shift(1); q.back() += count; total_sum += count; &#125; void Shift(int num_shifted) &#123; if (num_shifted &gt;= max_items) &#123; q = queue&lt;int&gt;(); total_sum = 0; return; &#125; while(num_shifted &gt; 0) &#123; q.push(0); num_shifted--; &#125; while(q.size() &gt; max_items) &#123; total_sum -= q.front(); q.pop(); &#125; &#125; int TotalSum() &#123; return total_sum; &#125;&#125;;class TrailingBucketCounter &#123; ConveyorQueue buckets; const int secs_per_bucket; time_t last_update_time; void Update(time_t now) &#123; int current_bucket = now / secs_per_bucket; int last_update_bucket = last_update_time / secs_per_bucket; buckets.Shift(current_bucket - last_update_bucket); last_update_time = now; &#125;public: TrailingBucketCounter(int num_buckets, int secs_per_bucket) : buckets(num_buckets), secs_per_bucket(secs_per_bucket), last_update_time(time(0)) /*书里没有初始化*/ &#123; &#125; void Add(int count, time_t now) &#123; Update(now); buckets.AddToBack(count); &#125; int TrailingCount(time_t now) &#123; Update(now); return buckets.TotalSum(); &#125;&#125;;class MinuteHourCounter &#123; TrailingBucketCounter minute_counts; TrailingBucketCounter hour_counts;public: MinuteHourCounter() : minute_counts(60, 1), hour_counts(60, 60) &#123; &#125; void Add(int count) &#123; time_t now = time(0); minute_counts.Add(count, now); hour_counts.Add(count, now); &#125; int MinuteCount() &#123; time_t now = time(0); return minute_counts.TrailingCount(now); &#125; int HourCount() &#123; time_t now = time(0); return hour_counts.TrailingCount(now); &#125;&#125;; 我的修改 上述例子中使用了队列来作为桶，如果采用数组来做，有如下变化： 使用的内存从一开始就固定下来，少去了每次进队出队的申请内存和释放内存操作 每次执行Shift的时间复杂度都为常数，且是固定的。如果数据只存在“位置相近”的几个桶上，会比使用使用队列慢一些。 使用队列时，每次新增事件，该事件的时间点都只能是当前时间点；使用数组后，可以新增过去时间发生的事件。 12345678910111213141516171819202122232425262728293031323334353637383940class ConveyorQueue &#123; vector&lt;int&gt; v; int total_sum; int GetValue(int index) &#123; if (index &gt;= 0 &amp;&amp; index &lt; v.size()) &#123; return v[index]; &#125; return 0; &#125;public: ConveyorQueue(int max_items) : total_sum(0) &#123; v.resize(max_items, 0); &#125; void AddToBack(int count) &#123; v[0] += count; total_sum += count; &#125; //据当前时间'pos单位时间'前的事件 void Add(int pos, int count) &#123; if(pos &gt;= 0 &amp;&amp; pos &lt; v.size()) &#123; v[pos] += count; total_sum += count; &#125; &#125; void Shift(int num_shifted) &#123; total_sum = 0; for(int i = v.size() - 1; i &gt;= 0; --i) &#123; v[i] = GetValue(i - num_shifted); total_sum += v[i]; &#125; &#125; int TotalSum() &#123; return total_sum; &#125;&#125;; 关于精准的的探讨以MinuteCounter为例。在这里，我们时间都是以秒作为单位，假设一件事发生在 t=0.99 时，我们会记成 t=0 。当我们在 t=60.1 调用程序时，会将当前时间当做 t=60 。 前两个方案会将 t=1,2,3…59,60 的频次累加并作为过去一分钟发生的次数，也就是会将 t=0.99 时的事件忽略，虽然理论上这是一分钟内发生的事。平均来讲，我们得到的会是过去 59.5 秒的时间内事件发生的次数。所幸在大多数情况这样的精度已经足够了。 第三个方案中按照给出的代码来实现，存在同样的误差。那是因为我们用 60 个桶来表示一分钟，一个桶表示一秒钟的间隔。如果我们用 120 个桶来表示一分钟，一个桶表示半秒钟，那我们便可以将误差减小一半。与此同时，我们所使用的内存也会增加一倍。这里就是误差与内存性能之间的衡量。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优雅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[香港贝澳营地&迪士尼]]></title>
    <url>%2Fblog%2F2017%2F07%2F10%2Fhongkong-beiao-disney%2F</url>
    <content type="text"><![CDATA[7月7日去了香港，9号回。在贝澳营地露营烧烤玩水，迪士尼玩了一天。做一点记录，也算作为一个攻略。 准备☆★ 表示推荐度，最高五星。 ★★★★★ 必备 ★★★★☆ 强烈推荐 ★★★☆☆ 推荐 ★★☆☆☆ 可以带 ★☆☆☆☆ 随便 必备 ★★★★★ 港澳通行证／身份证 ★★★★★ 港币，以备不时之需。大部分店能用银联(借记/信用)卡/支付宝/微信支付，但还是有一些地方只收现金。推荐尽量使用现金以外的付款方式，这样可以少换一点港币。 ★★★★★ 八达通。在香港地铁只能现金购买，要150港币，括50元押金和100元车费。如果只坐地铁，可以买地铁一日通/三日通等，相应时间内无限制坐地铁，但不能坐公交。然而去贝澳营地要坐公车….(八达通也可以过关前，在深圳这边先买好。) ★★★★★ 换洗衣物 ★★★★★ 洗漱用品 ★★★★★ 拖鞋 ★★★★★ 雨伞、帽子 ★★★★☆ 泳裤 ★★★☆☆ 泳帽、泳镜 扎营相关 ★★★★★ 帐篷、帆布。帆布有两个作用：帐篷可以一直留着门窗透气，晚上睡觉不会太闷；另外也能遮阳挡雨，不用一下雨就得躲进帐篷。 ★★★★★ 防潮垫/小毯子/大毛巾。沙滩地面不是很平整，而且略硬。 ★★★★☆ [充气]枕头、睡袋 ★★★☆☆ 吊床。晒太阳，发呆。 ★★★☆☆ 折叠凳子 ★★★★★ 移动电源。贝澳营地没有地方充电。所以带足充电宝。据说小卖部充电20$HK/次 ★★☆☆☆ 灯、光源、（充电式/手动档）风扇 食物相关 食材可以带过境，也可以在香港超市买；蔬菜/肉类不推荐带太多，毕竟没有冰箱不耐放。如果待的久，可以需要时去超市购买。 ★★★☆☆ 桶。方便用水，只推荐折叠桶，好带。 ★★★★☆ 面条、饺子 ★★★★☆ 蔬菜 ★★★★☆ 肉类 ★★★★★ 酒水，开瓶器 ★★★★★ 便携燃气炉、燃气罐、碳。这些东西过香港不查。如果是坐中旅大巴到香港就没什么问题；但如果是坐动车到深圳，能不能带上动车比较难说了，或者可以在深圳买 ★★★★★ 锅、烧烤架 ★★★★★ 一次性碗筷杯 Last But Not Least ★★★★★ 支付宝上“境外上网”可以买移动/联通的流量包，有1天/2天/3天等等，具体价格、激活方式看支付宝就清楚了。联通流量包需要提前购买 ★★★★★★★★★★ 妹子/汉子/基友/姬友/小朋友/大朋友。独乐乐不如众乐乐。 行程 大体说起来就是，周五坐大巴到香港，到贝澳营地登记、扎营、（雨中）烧烤；周六雨中畅游迪士尼；周日沙滩玩水，去市区吃个饭，然后就回广州了。 到达香港东涌 可以买中旅的大巴(广州&lt;-&gt;香港)往返票。（微信公众号：香港中旅粤港巴士。微信号：HKCTSBUS）。从广州坐到深圳湾过关，需要带行李下车，自行过关后，重新坐中旅的大巴，到香港荃湾下车，然后进地铁（如果没有八达通，可以在这里买），坐到荔景站，换线坐到东涌站。 也可以坐动车到深圳南站，在罗湖口岸过关，然后坐地铁到东涌。不过时间和金钱上不如上述方式。 东涌站外超市补充物资 如果物资齐备也可以跳过 地铁站出来就有超市，可以在这里买齐必须的物资，像是木炭，或者新鲜肉类，速冻饺子等 到达贝澳营地 东涌站外找到福东广场站，坐屿巴3M到新围村站下车 车上有几段路没有信号。一路上开始能看到大海的风景。 下车后，步行一千米左右到达贝澳营地大门，此处请善用导航/问路人 到达营地后，首先在门口管理处登记，得到营地使用权。 贝澳营地，有52个独立的营区，铁栅栏围起来，还有一套桌椅。 有香港身份证可以提前预约营地。不然就只能到达后用港澳通行证申请。 我们是周五晚上六七点到达，只剩下2个独立营区。 如果没有独立营区就只能去大草坪搭建帐篷，大草坪没有划分独立的空间。 周末才到，就可能没有独立营区。 十一长假到，很可能大草坪也没有多少位置。 营地完全免费！！！ 营地有专门供烧烤的地方，也有洗手间、换衣间、冲凉间（冲凉是半室外的！），小卖部（晚上好像没开，当然这里卖东西还是要钱的，而且比较贵）。 安营扎寨完毕，便可以生火烧烤、煮面下饺子。 酒足饭饱，洗漱完毕，在海浪声中入眠也是一种很不一样的体验 早上起来，在海边静静地聆听，边小酌几杯，别有一番滋味。 迪士尼 如果不想去迪士尼，可以继续在营地海边玩水 如果想去迪士尼，最好有3天以上的游玩时间，前后各一天可以安顿，中间有完整的1天逛迪士尼，门票才不会亏了 从营地出发，坐屿巴3M到东涌市中心站，进地铁站，坐到欣澳站，转迪士尼线到迪士尼站下车 出站就能看到迪士尼了 迪士尼门票可以在某宝或蚂蜂窝app（比某宝便宜）上买。 成人票是400+ 饭票是200（包括两张正餐券[一张需在16点前使用，一张需在16点后使用]，一张小吃券，一张打折券）。 迪士尼的几家餐厅都差不多，有中餐、牛排、日式拉面等套餐，标价是120+、140+港币不等。饭票的正餐券可以任选一个套餐，划算很多。 迪士尼进门的时候会搜包，不能带吃的，当然带瓶水还是可以的。 但是不搜身，身上带点零食还是可以的，要多带就得看神通了。 迪士尼很多项目都要排队，和项目好玩程度及项目花费时间成正比。 （所幸去的那天下阵雨了，天气比较凉爽。不然在烈日下排队还是一件比较郁闷的事。） 部分项目有一种称为FastPass的快捷通道：在该项目附近的机器处刷门票，会得到一张该项目的FastPass门票，上面有一个时间段，在该时间段来玩项目，不用排队，期间就可以去玩人比较少的项目，能省不少时间。需要注意FastPass领取要间隔一段时间。 一些游乐项目（可参考微信公众号“香港迪士尼乐园度假区”，微信号“HKDisneylandResort”，能看到节目时间表和一些介绍。另外进门不远就有园区介绍宣传单。） 太空飞碟室内过山车。配上机战的画面和音效，犹如身临其境。 灰熊山极速矿车室外过山车。有几段路是倒着开的。迪士尼的过山车倾斜角度都不会很大。 玩具兵团跳降伞固定座位，垂直上下，体验超重失重。 狮子王庆典 大型歌舞剧，时长半小时，英语对白，白话旁白，必看。每天有几场，具体时间以公众号或官网为准。 夜间巡游20：20开始。如果下雨就会取消。（当时就没看到sad） 烟花表演21：00，烟花在睡公主城堡，可在美国小镇大街观看。19：00开始，就陆续有人吃过晚餐在等了。椅子比较少，晚去就只能站着了，或者自带板凳。烟花效果很赞，有伴就更佳。 还有很多类似项目：室内，坐车，一路观赏各种不同景色、影片，某些时候，会有冷风、清水打到身上。不一一道来了。 总而言之，能玩一天体验了大部分项目的的话，门票还是不亏的。特别是有小孩/妹子（tan90°）的话怎么都不亏。 自行选择 继续迪士尼未完的项目。（那迪士尼门票记得买两日票，比两张单日票便宜） 继续玩水 到市区逛逛，买点东西，吃点美食 如果是坐大巴来回，记得选个方便的上车点，提前跟中旅说好地点和时间，然后到时间就可以悠哉地去坐大巴回家，结束这段别样的旅程。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>香港</tag>
        <tag>旅游</tag>
        <tag>露营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2017%2F05%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[有善始者实繁，能克终者盖寡。 又双叒叕开始写博客了。 不知道这次能坚持多久。 行百里者半九十，且行且珍惜。 2017.08.09立一个flag，博客月更。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>